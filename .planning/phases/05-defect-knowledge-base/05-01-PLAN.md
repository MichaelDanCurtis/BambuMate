---
phase: 05-defect-knowledge-base
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/mapper/mod.rs
  - src-tauri/src/mapper/types.rs
  - src-tauri/src/mapper/rules.rs
  - src-tauri/src/mapper/engine.rs
  - src-tauri/config/defect_rules.toml
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Defect-to-setting rules are loaded from TOML config, not hardcoded Rust"
    - "Given a defect type and severity, engine produces ranked parameter adjustments"
    - "When multiple defect fixes conflict, engine identifies and reports the conflict"
    - "All recommendations respect material-specific safe operating ranges"
  artifacts:
    - path: "src-tauri/config/defect_rules.toml"
      provides: "Data-driven defect-to-parameter mappings"
      contains: "[defects."
    - path: "src-tauri/src/mapper/types.rs"
      provides: "Typed structs for rules, adjustments, recommendations, conflicts"
      exports: ["RulesConfig", "DefectRule", "Adjustment", "Recommendation", "Conflict"]
    - path: "src-tauri/src/mapper/engine.rs"
      provides: "Rule evaluation with ranking and conflict detection"
      exports: ["RuleEngine"]
    - path: "src-tauri/src/mapper/mod.rs"
      provides: "Public module API"
      exports: ["RuleEngine", "default_rules", "load_rules"]
  key_links:
    - from: "src-tauri/src/mapper/engine.rs"
      to: "src-tauri/src/scraper/validation.rs"
      via: "constraints_for_material import"
      pattern: "use crate::scraper::validation::constraints_for_material"
    - from: "src-tauri/src/mapper/rules.rs"
      to: "src-tauri/config/defect_rules.toml"
      via: "include_str! macro"
      pattern: "include_str!"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/mapper/mod.rs"
      via: "pub mod mapper"
      pattern: "pub mod mapper"
---

<objective>
Create a TOML-driven rule engine that maps detected print defects to ranked, conflict-aware profile parameter recommendations.

Purpose: Phase 6 (AI Print Analysis) will detect defects from photos -- this engine translates those detections into actionable profile changes. Without it, defect detection is useless.

Output: A `mapper` module with types, TOML loading, evaluation engine, and conflict detection. Default rules embedded in binary via `include_str!`.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-defect-knowledge-base/05-RESEARCH.md

# Integration points from prior phases
@src-tauri/src/scraper/validation.rs (MaterialConstraints, constraints_for_material)
@src-tauri/src/scraper/types.rs (MaterialType enum)
@src-tauri/src/profile/types.rs (FilamentProfile)
@src-tauri/src/lib.rs (module registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mapper types and TOML rule configuration</name>
  <files>
    src-tauri/src/mapper/types.rs
    src-tauri/src/mapper/rules.rs
    src-tauri/config/defect_rules.toml
  </files>
  <action>
Create the mapper module foundation:

1. **Create `src-tauri/config/defect_rules.toml`** with comprehensive defect mappings:
   - Define defect types with metadata: stringing, warping, layer_adhesion, elephants_foot, under_extrusion, over_extrusion, z_banding
   - Each defect has: display_name, description, severity_range
   - Define rules with: defect type, severity_min threshold, adjustments array
   - Each adjustment has: parameter (exact Bambu Studio field name), operation (increase/decrease/set), amount, unit, priority (1=primary fix), rationale
   - Define known conflicts between parameters (e.g., retraction vs flow ratio)
   - Use exact Bambu Studio parameter names from research: `filament_retraction_length`, `nozzle_temperature`, `fan_min_speed`, `fan_max_speed`, `filament_flow_ratio`, `cool_plate_temp`, `hot_plate_temp`, `nozzle_temperature_initial_layer`, `filament_retraction_speed`, `pressure_advance`

2. **Create `src-tauri/src/mapper/types.rs`** with serde-deserializable structs:
   ```rust
   use serde::{Deserialize, Serialize};
   use std::collections::HashMap;

   #[derive(Debug, Clone, Deserialize)]
   pub struct RulesConfig {
       pub defects: HashMap<String, DefectInfo>,
       pub rules: Vec<DefectRule>,
       #[serde(default)]
       pub conflicts: Vec<ConflictDefinition>,
   }

   #[derive(Debug, Clone, Deserialize)]
   pub struct DefectInfo {
       pub display_name: String,
       pub description: String,
       pub severity_range: [f32; 2],
   }

   #[derive(Debug, Clone, Deserialize)]
   pub struct DefectRule {
       pub defect: String,
       #[serde(default)]
       pub severity_min: Option<f32>,
       pub adjustments: Vec<Adjustment>,
   }

   #[derive(Debug, Clone, Deserialize)]
   pub struct Adjustment {
       pub parameter: String,
       pub operation: Operation,
       pub amount: f32,
       pub unit: String,
       pub priority: u8,
       pub rationale: String,
   }

   #[derive(Debug, Clone, Copy, Deserialize, PartialEq)]
   #[serde(rename_all = "lowercase")]
   pub enum Operation {
       Increase,
       Decrease,
       Set,
   }

   #[derive(Debug, Clone, Deserialize)]
   pub struct ConflictDefinition {
       pub name: String,
       pub description: String,
       pub parameters: Vec<String>,
   }
   ```

   Also add output types (Serialize for frontend):
   ```rust
   #[derive(Debug, Clone, Serialize)]
   pub struct Recommendation {
       pub defect: String,
       pub parameter: String,
       pub current_value: f32,
       pub recommended_value: f32,
       pub priority: u8,
       pub rationale: String,
       pub was_clamped: bool,
   }

   #[derive(Debug, Clone, Serialize)]
   pub struct Conflict {
       pub parameter: String,
       pub conflicting_defects: Vec<String>,
       pub description: String,
   }

   #[derive(Debug, Clone, Serialize)]
   pub struct EvaluationResult {
       pub recommendations: Vec<Recommendation>,
       pub conflicts: Vec<Conflict>,
   }

   /// Input defect from AI analysis (to be used in Phase 6)
   #[derive(Debug, Clone, Deserialize)]
   pub struct DetectedDefect {
       pub defect_type: String,
       pub severity: f32,
       pub confidence: f32,
   }
   ```

3. **Create `src-tauri/src/mapper/rules.rs`** for TOML loading:
   ```rust
   use anyhow::Result;
   use std::path::Path;
   use super::types::RulesConfig;

   /// Load rules from a TOML file path
   pub fn load_rules(path: &Path) -> Result<RulesConfig> {
       let content = std::fs::read_to_string(path)?;
       let config: RulesConfig = toml::from_str(&content)?;
       Ok(config)
   }

   /// Get default rules embedded in binary
   pub fn default_rules() -> RulesConfig {
       const DEFAULT_RULES: &str = include_str!("../../config/defect_rules.toml");
       toml::from_str(DEFAULT_RULES).expect("embedded defect_rules.toml must be valid TOML")
   }
   ```

**Defect rules to include in TOML** (from research):
- Stringing: +retraction_length, -nozzle_temp, +retraction_speed
- Warping: +bed_temp, -fan_speed, +initial_layer_temp
- Layer adhesion: +nozzle_temp, -fan_speed, +flow_ratio
- Elephant's foot: -bed_temp, -initial_layer_temp
- Under-extrusion: +flow_ratio, +nozzle_temp, -retraction_length
- Over-extrusion: -flow_ratio, -nozzle_temp
- Z-banding: note as primarily mechanical, suggest pressure_advance calibration

**Conflicts to define:**
- retraction_extrusion_tradeoff: filament_retraction_length vs filament_flow_ratio
- temperature_stringing_adhesion: nozzle_temperature affects stringing vs layer adhesion
- cooling_warping_stringing: fan_min_speed/fan_max_speed affects warping vs stringing
  </action>
  <verify>
    Run `cargo check -p bambumate` to verify types compile.
    Run `cargo test -p bambumate mapper::rules::tests` to verify TOML parsing works.
  </verify>
  <done>
    - defect_rules.toml exists with 7 defect types and their adjustment rules
    - types.rs compiles with all structs implementing required derives
    - rules.rs can load embedded TOML via default_rules()
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement rule engine with ranking and conflict detection</name>
  <files>
    src-tauri/src/mapper/engine.rs
    src-tauri/src/mapper/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
Create the rule evaluation engine:

1. **Create `src-tauri/src/mapper/engine.rs`**:

   ```rust
   use crate::scraper::types::MaterialType;
   use crate::scraper::validation::constraints_for_material;
   use super::types::*;

   pub struct RuleEngine {
       rules: RulesConfig,
   }

   impl RuleEngine {
       pub fn new(rules: RulesConfig) -> Self {
           Self { rules }
       }

       /// Evaluate detected defects against rules to produce recommendations
       pub fn evaluate(
           &self,
           defects: &[DetectedDefect],
           current_values: &std::collections::HashMap<String, f32>,
           material: &MaterialType,
       ) -> EvaluationResult {
           let mut recommendations = Vec::new();

           for defect in defects {
               // Find rules matching this defect type and severity threshold
               let applicable_rules: Vec<_> = self.rules.rules.iter()
                   .filter(|r| r.defect == defect.defect_type)
                   .filter(|r| r.severity_min.map_or(true, |min| defect.severity >= min))
                   .collect();

               for rule in applicable_rules {
                   for adj in &rule.adjustments {
                       let current = current_values.get(&adj.parameter).copied().unwrap_or(0.0);

                       // Scale adjustment by severity (linear scaling)
                       let raw_delta = match adj.operation {
                           Operation::Increase => adj.amount * defect.severity,
                           Operation::Decrease => -adj.amount * defect.severity,
                           Operation::Set => adj.amount - current,
                       };

                       let new_value = current + raw_delta;

                       // Clamp to material-safe range
                       let (clamped_value, was_clamped) = self.clamp_to_safe_range(
                           &adj.parameter,
                           new_value,
                           material,
                       );

                       recommendations.push(Recommendation {
                           defect: defect.defect_type.clone(),
                           parameter: adj.parameter.clone(),
                           current_value: current,
                           recommended_value: clamped_value,
                           priority: adj.priority,
                           rationale: adj.rationale.clone(),
                           was_clamped,
                       });
                   }
               }
           }

           // Sort by priority (lower = more important)
           recommendations.sort_by_key(|r| r.priority);

           // Detect conflicts
           let conflicts = self.detect_conflicts(&recommendations);

           EvaluationResult {
               recommendations,
               conflicts,
           }
       }

       /// Clamp a value to material-safe operating range
       fn clamp_to_safe_range(
           &self,
           param: &str,
           value: f32,
           material: &MaterialType,
       ) -> (f32, bool) {
           let constraints = constraints_for_material(material);

           let (min, max): (f32, f32) = match param {
               "nozzle_temperature" | "nozzle_temperature_initial_layer" => {
                   (constraints.nozzle_temp_min as f32, constraints.nozzle_temp_max as f32)
               }
               "cool_plate_temp" | "hot_plate_temp" | "textured_plate_temp" => {
                   (constraints.bed_temp_min as f32, constraints.bed_temp_max as f32)
               }
               "filament_retraction_length" => (0.0, 15.0),
               "filament_retraction_speed" => (10.0, 100.0),
               "filament_flow_ratio" => (0.85, 1.15),
               "fan_min_speed" | "fan_max_speed" | "overhang_fan_speed" => (0.0, 100.0),
               "pressure_advance" => (0.0, 0.1),
               _ => return (value, false), // No constraints for unknown params
           };

           if value < min {
               (min, true)
           } else if value > max {
               (max, true)
           } else {
               (value, false)
           }
       }

       /// Detect conflicts where same parameter is adjusted in opposite directions
       fn detect_conflicts(&self, recommendations: &[Recommendation]) -> Vec<Conflict> {
           use std::collections::HashMap;
           let mut conflicts = Vec::new();

           // Group by parameter
           let mut by_param: HashMap<&str, Vec<&Recommendation>> = HashMap::new();
           for rec in recommendations {
               by_param.entry(&rec.parameter).or_default().push(rec);
           }

           // Check for opposite-direction adjustments on same parameter
           for (param, recs) in &by_param {
               if recs.len() > 1 {
                   let directions: Vec<i8> = recs.iter()
                       .map(|r| {
                           let delta = r.recommended_value - r.current_value;
                           if delta > 0.001 { 1 }
                           else if delta < -0.001 { -1 }
                           else { 0 }
                       })
                       .collect();

                   let has_increase = directions.iter().any(|&d| d > 0);
                   let has_decrease = directions.iter().any(|&d| d < 0);

                   if has_increase && has_decrease {
                       conflicts.push(Conflict {
                           parameter: param.to_string(),
                           conflicting_defects: recs.iter().map(|r| r.defect.clone()).collect(),
                           description: format!(
                               "Multiple defects require opposite adjustments to {}",
                               param
                           ),
                       });
                   }
               }
           }

           // Check defined conflict pairs from rules config
           for def in &self.rules.conflicts {
               let affected: Vec<&Recommendation> = recommendations.iter()
                   .filter(|r| def.parameters.contains(&r.parameter))
                   .collect();

               if affected.len() > 1 {
                   let defects: Vec<String> = affected.iter()
                       .map(|r| r.defect.clone())
                       .collect::<std::collections::HashSet<_>>()
                       .into_iter()
                       .collect();

                   if defects.len() > 1 {
                       conflicts.push(Conflict {
                           parameter: def.parameters.join(", "),
                           conflicting_defects: defects,
                           description: def.description.clone(),
                       });
                   }
               }
           }

           // Deduplicate conflicts
           conflicts.sort_by(|a, b| a.parameter.cmp(&b.parameter));
           conflicts.dedup_by(|a, b| a.parameter == b.parameter);

           conflicts
       }

       /// Get defect display info
       pub fn get_defect_info(&self, defect_type: &str) -> Option<&DefectInfo> {
           self.rules.defects.get(defect_type)
       }

       /// List all known defect types
       pub fn known_defect_types(&self) -> Vec<&str> {
           self.rules.defects.keys().map(|s| s.as_str()).collect()
       }
   }
   ```

2. **Create `src-tauri/src/mapper/mod.rs`**:
   ```rust
   mod types;
   mod rules;
   mod engine;

   pub use types::*;
   pub use rules::{default_rules, load_rules};
   pub use engine::RuleEngine;
   ```

3. **Update `src-tauri/src/lib.rs`** to register the mapper module:
   - Add `pub mod mapper;` to the module declarations (after `pub mod scraper;`)

4. **Make MaterialConstraints fields public** in `src-tauri/src/scraper/validation.rs`:
   - Change `nozzle_temp_min: u16` to `pub nozzle_temp_min: u16` (and same for other fields)
   - This allows the mapper engine to read constraint values

5. **Add unit tests** in engine.rs:
   - Test that stringing defect produces retraction increase recommendation
   - Test that severity scaling works (severity 0.5 produces half the adjustment)
   - Test that recommendations are sorted by priority
   - Test that conflicting adjustments are detected
   - Test that values are clamped to material-safe ranges
  </action>
  <verify>
    Run `cargo check -p bambumate` to verify the module compiles.
    Run `cargo test -p bambumate mapper` to verify all tests pass.
    Verify `pub mod mapper` is in lib.rs.
  </verify>
  <done>
    - RuleEngine can be constructed with default_rules()
    - evaluate() produces ranked recommendations sorted by priority
    - Conflicting adjustments are detected and reported
    - Values are clamped to material-specific safe ranges
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests and documentation</name>
  <files>
    src-tauri/src/mapper/engine.rs (additional tests)
    src-tauri/src/mapper/mod.rs (doc comments)
  </files>
  <action>
Add integration-level tests and documentation:

1. **Add integration tests to engine.rs** (in `#[cfg(test)]` module):

   ```rust
   #[cfg(test)]
   mod tests {
       use super::*;
       use crate::mapper::default_rules;

       fn make_engine() -> RuleEngine {
           RuleEngine::new(default_rules())
       }

       fn current_profile_values() -> std::collections::HashMap<String, f32> {
           let mut values = std::collections::HashMap::new();
           values.insert("nozzle_temperature".to_string(), 210.0);
           values.insert("filament_retraction_length".to_string(), 0.8);
           values.insert("filament_flow_ratio".to_string(), 1.0);
           values.insert("fan_min_speed".to_string(), 35.0);
           values.insert("cool_plate_temp".to_string(), 60.0);
           values
       }

       #[test]
       fn test_stringing_produces_retraction_increase() {
           let engine = make_engine();
           let defects = vec![DetectedDefect {
               defect_type: "stringing".to_string(),
               severity: 0.7,
               confidence: 0.9,
           }];
           let values = current_profile_values();
           let result = engine.evaluate(&defects, &values, &MaterialType::PLA);

           // Should have retraction length recommendation
           let retraction_rec = result.recommendations.iter()
               .find(|r| r.parameter == "filament_retraction_length");
           assert!(retraction_rec.is_some(), "Should recommend retraction adjustment");

           let rec = retraction_rec.unwrap();
           assert!(rec.recommended_value > rec.current_value, "Should increase retraction");
       }

       #[test]
       fn test_severity_scaling() {
           let engine = make_engine();

           // Low severity
           let low_defects = vec![DetectedDefect {
               defect_type: "stringing".to_string(),
               severity: 0.3,
               confidence: 0.9,
           }];

           // High severity
           let high_defects = vec![DetectedDefect {
               defect_type: "stringing".to_string(),
               severity: 0.9,
               confidence: 0.9,
           }];

           let values = current_profile_values();
           let low_result = engine.evaluate(&low_defects, &values, &MaterialType::PLA);
           let high_result = engine.evaluate(&high_defects, &values, &MaterialType::PLA);

           let low_rec = low_result.recommendations.iter()
               .find(|r| r.parameter == "filament_retraction_length").unwrap();
           let high_rec = high_result.recommendations.iter()
               .find(|r| r.parameter == "filament_retraction_length").unwrap();

           // High severity should produce larger adjustment
           let low_delta = (low_rec.recommended_value - low_rec.current_value).abs();
           let high_delta = (high_rec.recommended_value - high_rec.current_value).abs();
           assert!(high_delta > low_delta, "High severity should produce larger adjustment");
       }

       #[test]
       fn test_priority_sorting() {
           let engine = make_engine();
           let defects = vec![DetectedDefect {
               defect_type: "stringing".to_string(),
               severity: 0.8,
               confidence: 0.9,
           }];
           let values = current_profile_values();
           let result = engine.evaluate(&defects, &values, &MaterialType::PLA);

           // Verify recommendations are sorted by priority
           for window in result.recommendations.windows(2) {
               assert!(window[0].priority <= window[1].priority,
                   "Recommendations should be sorted by priority");
           }
       }

       #[test]
       fn test_conflict_detection() {
           let engine = make_engine();

           // Stringing wants more retraction, under-extrusion wants less
           let defects = vec![
               DetectedDefect {
                   defect_type: "stringing".to_string(),
                   severity: 0.7,
                   confidence: 0.9,
               },
               DetectedDefect {
                   defect_type: "under_extrusion".to_string(),
                   severity: 0.6,
                   confidence: 0.8,
               },
           ];
           let values = current_profile_values();
           let result = engine.evaluate(&defects, &values, &MaterialType::PLA);

           // Should detect retraction conflict
           let has_retraction_conflict = result.conflicts.iter()
               .any(|c| c.parameter.contains("retraction") ||
                       c.conflicting_defects.contains(&"stringing".to_string()));

           assert!(has_retraction_conflict || !result.conflicts.is_empty(),
               "Should detect conflict between stringing and under-extrusion fixes");
       }

       #[test]
       fn test_safe_range_clamping() {
           let engine = make_engine();

           // Very severe defect that would push temp out of safe range
           let defects = vec![DetectedDefect {
               defect_type: "layer_adhesion".to_string(),
               severity: 1.0,
               confidence: 0.9,
           }];

           let mut values = current_profile_values();
           values.insert("nozzle_temperature".to_string(), 230.0); // Near PLA max

           let result = engine.evaluate(&defects, &values, &MaterialType::PLA);

           // Temperature recommendation should not exceed PLA max (235)
           let temp_rec = result.recommendations.iter()
               .find(|r| r.parameter == "nozzle_temperature");

           if let Some(rec) = temp_rec {
               assert!(rec.recommended_value <= 235.0,
                   "PLA temp should not exceed 235C, got {}", rec.recommended_value);
           }
       }

       #[test]
       fn test_known_defect_types() {
           let engine = make_engine();
           let types = engine.known_defect_types();

           assert!(types.contains(&"stringing"), "Should know stringing");
           assert!(types.contains(&"warping"), "Should know warping");
           assert!(types.contains(&"layer_adhesion"), "Should know layer_adhesion");
           assert!(types.contains(&"under_extrusion"), "Should know under_extrusion");
       }

       #[test]
       fn test_empty_defects_returns_empty_result() {
           let engine = make_engine();
           let result = engine.evaluate(&[], &current_profile_values(), &MaterialType::PLA);

           assert!(result.recommendations.is_empty());
           assert!(result.conflicts.is_empty());
       }
   }
   ```

2. **Add module-level documentation** to mod.rs:
   ```rust
   //! Defect-to-parameter mapping engine for 3D print troubleshooting.
   //!
   //! This module provides a TOML-driven rule engine that translates detected
   //! print defects into ranked, conflict-aware profile parameter recommendations.
   //!
   //! # Architecture
   //!
   //! - **Rules**: Loaded from TOML config at startup (or embedded defaults)
   //! - **Evaluation**: Defects + current profile -> ranked recommendations
   //! - **Conflicts**: Automatically detected when fixes contradict each other
   //! - **Safe ranges**: All recommendations clamped to material-specific limits
   //!
   //! # Example
   //!
   //! ```ignore
   //! use bambumate::mapper::{RuleEngine, default_rules, DetectedDefect};
   //! use bambumate::scraper::types::MaterialType;
   //!
   //! let engine = RuleEngine::new(default_rules());
   //!
   //! let defects = vec![DetectedDefect {
   //!     defect_type: "stringing".to_string(),
   //!     severity: 0.7,
   //!     confidence: 0.9,
   //! }];
   //!
   //! let current_values = std::collections::HashMap::from([
   //!     ("nozzle_temperature".to_string(), 215.0),
   //!     ("filament_retraction_length".to_string(), 0.8),
   //! ]);
   //!
   //! let result = engine.evaluate(&defects, &current_values, &MaterialType::PLA);
   //!
   //! for rec in result.recommendations {
   //!     println!("{}: {} -> {} ({})",
   //!         rec.parameter, rec.current_value, rec.recommended_value, rec.rationale);
   //! }
   //!
   //! for conflict in result.conflicts {
   //!     println!("Warning: {} - {}", conflict.parameter, conflict.description);
   //! }
   //! ```
   ```

3. **Verify the complete module works end-to-end**:
   - Build with `cargo build -p bambumate`
   - Run all tests with `cargo test -p bambumate mapper`
  </action>
  <verify>
    Run `cargo test -p bambumate mapper` -- all tests pass.
    Run `cargo doc -p bambumate --no-deps` -- documentation generates without warnings.
    Run `cargo clippy -p bambumate` -- no warnings in mapper module.
  </verify>
  <done>
    - 8+ unit tests covering: basic evaluation, severity scaling, priority sorting, conflict detection, safe-range clamping, edge cases
    - Module documentation with usage example
    - Clean clippy output
    - All DMAP requirements verified: DMAP-01 (TOML config), DMAP-02 (ranked recommendations), DMAP-03 (conflict handling)
  </done>
</task>

</tasks>

<verification>
## Phase 5 Requirements Check

**DMAP-01: Defect-to-setting rules stored as data (TOML config), not hardcoded**
- Verify: `cat src-tauri/config/defect_rules.toml` shows all mappings in TOML format
- Verify: No match statements on defect types in engine.rs (rules loaded from config)

**DMAP-02: Rules generate ranked recommendations (most likely cause first)**
- Verify: `cargo test mapper::tests::test_priority_sorting` passes
- Verify: Recommendations in EvaluationResult are sorted by priority field

**DMAP-03: Rule engine handles interaction conflicts**
- Verify: `cargo test mapper::tests::test_conflict_detection` passes
- Verify: EvaluationResult.conflicts contains detected conflicts when present

**Integration readiness for Phase 6:**
- Verify: `use bambumate::mapper::{RuleEngine, default_rules}` compiles from external crate
</verification>

<success_criteria>
1. `cargo build -p bambumate` succeeds with no errors
2. `cargo test -p bambumate mapper` passes all tests (8+)
3. `defect_rules.toml` contains 7 defect types with parameter adjustments
4. Adding a new defect requires only TOML edit, no Rust code changes
5. `RuleEngine::evaluate()` returns ranked recommendations sorted by priority
6. Conflicting adjustments (e.g., stringing + under-extrusion on retraction) are detected
7. All recommendations respect material-specific temperature/retraction limits
</success_criteria>

<output>
After completion, create `.planning/phases/05-defect-knowledge-base/05-01-SUMMARY.md` following the template at `@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md`
</output>
