---
phase: 01-app-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - index.html
  - Trunk.toml
  - src/main.rs
  - src/app.rs
  - src/commands.rs
  - src/pages/mod.rs
  - src/pages/home.rs
  - src/pages/settings.rs
  - src/pages/health.rs
  - src/components/mod.rs
  - src/components/sidebar.rs
  - style/main.css
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/build.rs
  - src-tauri/capabilities/default.json
  - src-tauri/src/main.rs
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/keychain.rs
  - src-tauri/src/commands/config.rs
  - src-tauri/src/commands/health.rs
  - src-tauri/src/error.rs
autonomous: true

must_haves:
  truths:
    - "App launches on macOS and displays a window with sidebar navigation"
    - "User can click sidebar links to navigate between Home, Settings, and Health Check pages"
    - "Tauri backend starts and responds to invoke() calls from the frontend"
  artifacts:
    - path: "src/app.rs"
      provides: "Root App component with Router, sidebar layout, and three routes"
      contains: "Router"
    - path: "src/components/sidebar.rs"
      provides: "Navigation sidebar with links to all views"
      contains: "sidebar"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri app builder with plugin and command registration"
      contains: "invoke_handler"
    - path: "src-tauri/tauri.conf.json"
      provides: "Tauri config with withGlobalTauri, Trunk integration, bundle settings"
      contains: "withGlobalTauri"
    - path: "src/commands.rs"
      provides: "wasm_bindgen invoke helpers for frontend-backend communication"
      contains: "invoke"
    - path: "src-tauri/src/commands/keychain.rs"
      provides: "Tauri commands for get/set/delete API keys via OS keychain"
      contains: "set_api_key"
    - path: "src-tauri/src/commands/health.rs"
      provides: "Tauri command for health check reporting"
      contains: "run_health_check"
  key_links:
    - from: "src/commands.rs"
      to: "window.__TAURI__.core.invoke()"
      via: "wasm_bindgen extern block"
      pattern: "wasm_bindgen.*js_namespace.*__TAURI__.*core"
    - from: "src/app.rs"
      to: "src/pages/*.rs"
      via: "leptos_router Routes"
      pattern: "Route.*path.*view"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/*.rs"
      via: "tauri::generate_handler!"
      pattern: "generate_handler"
---

<objective>
Scaffold a Tauri 2.0 + Leptos 0.8 desktop application with a navigable app shell (sidebar + routed pages) and the complete Tauri backend command layer for keychain, config, and health check operations.

Purpose: This creates the entire runnable application skeleton that Plan 02 builds on. The app launches, navigates between views, and the backend command infrastructure is ready for the frontend to wire to.

Output: A working Tauri + Leptos app with sidebar navigation between Home, Settings, and Health Check pages, plus backend Tauri commands for keychain access, preferences, and health checks (commands exist and are registered but not yet wired to UI).
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-app-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Tauri 2.0 + Leptos project with Trunk bundler</name>
  <files>
    Cargo.toml
    index.html
    Trunk.toml
    src/main.rs
    src-tauri/Cargo.toml
    src-tauri/tauri.conf.json
    src-tauri/build.rs
    src-tauri/capabilities/default.json
    src-tauri/src/main.rs
    src-tauri/src/lib.rs
  </files>
  <action>
    Create the project from scratch (do NOT use create-tauri-app -- it generates a minimal template we'd mostly overwrite). Build the structure manually for full control.

    **Frontend Cargo.toml** (project root):
    - Package name: `bambumate`
    - Edition 2021
    - Dependencies: leptos 0.8 with `features = ["csr"]`, leptos_router 0.8 with `features = ["csr"]`, wasm-bindgen 0.2, serde 1.0 with `features = ["derive"]`, serde_json 1.0, serde-wasm-bindgen 0.6

    **index.html** (project root):
    - Standard Trunk entry point HTML
    - Link to `style/main.css`
    - `<div id="app"></div>` mount point
    - Trunk will handle WASM loading via data-trunk attributes on link/script tags

    **Trunk.toml**:
    - `[build]` target = "./index.html"
    - `[watch]` ignore = ["./src-tauri"]
    - `[serve]` port = 1420, open = false, ws_protocol = "ws"

    **src/main.rs**:
    - Mount Leptos app: `leptos::mount::mount_to_body(App);` (Leptos 0.8 CSR pattern)
    - Import App from app module

    **src-tauri/Cargo.toml**:
    - Package name: `bambumate-tauri`
    - Dependencies: tauri 2 (with `features = []`), tauri-plugin-store 2, serde 1.0, serde_json 1.0, keyring 3.6 with `features = ["apple-native"]`, anyhow 1.0, thiserror 2.0, tracing 0.1, tracing-subscriber 0.3 with `features = ["env-filter"]`, dirs 6.0
    - Build dependencies: tauri-build 2 with `features = []`

    **src-tauri/build.rs**:
    - Standard `tauri_build::build()` call

    **src-tauri/tauri.conf.json**:
    - $schema: "https://schema.tauri.app/config/2"
    - productName: "BambuMate"
    - version: "0.1.0"
    - identifier: "com.bambumate.app"
    - build.beforeDevCommand: "trunk serve"
    - build.devUrl: "http://localhost:1420"
    - build.beforeBuildCommand: "trunk build"
    - build.frontendDist: "../dist"
    - app.withGlobalTauri: true (CRITICAL -- without this, invoke() fails silently)
    - app.windows: single window, title "BambuMate", 1200x800, resizable
    - bundle.active: true
    - bundle.targets: "all"
    - bundle.icon paths for macOS icons (use Tauri defaults)
    - bundle.macOS.dmg settings per research (app position, folder position, window size)
    - bundle.macOS.minimumSystemVersion: "10.15"

    **src-tauri/capabilities/default.json**:
    - Allow all custom commands (keychain, health, config)
    - Include "store:allow-get", "store:allow-set", "store:allow-save", "store:allow-load" for tauri-plugin-store
    - Use permissive defaults for Phase 1; tighten in later phases

    **src-tauri/src/main.rs**:
    - Standard `main()` that calls `bambumate_tauri::run()`
    - `#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]` attribute

    **src-tauri/src/lib.rs**:
    - Minimal placeholder: register tauri_plugin_store, register empty command handler
    - Will be expanded in Task 3 when commands are added

    **Create directories**: src-tauri/icons/ (copy or generate default Tauri icons using `cargo tauri icon` if available, or create placeholder PNGs)
  </action>
  <verify>
    1. `cd /Users/michaelcurtis/Development/BambuMate && cargo check` succeeds for the frontend crate
    2. `cd /Users/michaelcurtis/Development/BambuMate/src-tauri && cargo check` succeeds for the backend crate
    3. Confirm `src-tauri/tauri.conf.json` contains `"withGlobalTauri": true`
    4. Confirm `Trunk.toml` has port 1420
  </verify>
  <done>
    Both crates compile without errors. Project structure matches the research architecture. Tauri config has withGlobalTauri enabled and Trunk port matches devUrl.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create app shell with sidebar navigation and routed pages</name>
  <files>
    src/app.rs
    src/commands.rs
    src/pages/mod.rs
    src/pages/home.rs
    src/pages/settings.rs
    src/pages/health.rs
    src/components/mod.rs
    src/components/sidebar.rs
    style/main.css
  </files>
  <action>
    **src/commands.rs** -- Frontend invoke helpers:
    - Define the wasm_bindgen extern block for `window.__TAURI__.core.invoke()`:
      ```rust
      #[wasm_bindgen(js_namespace = ["window", "__TAURI__", "core"], catch)]
      async fn invoke(cmd: &str, args: JsValue) -> Result<JsValue, JsValue>;
      ```
    - Create typed helper functions that will be used by pages:
      - `pub async fn set_api_key(service: &str, key: &str) -> Result<(), String>`
      - `pub async fn get_api_key(service: &str) -> Result<Option<String>, String>`
      - `pub async fn delete_api_key(service: &str) -> Result<(), String>`
      - `pub async fn run_health_check() -> Result<HealthReport, String>` (define HealthReport struct matching backend)
      - `pub async fn get_preference(key: &str) -> Result<Option<String>, String>`
      - `pub async fn set_preference(key: &str, value: &str) -> Result<(), String>`
    - Each helper serializes args with `serde_wasm_bindgen::to_value()` and deserializes responses with `serde_wasm_bindgen::from_value()`
    - HealthReport struct: bambu_studio_installed (bool), bambu_studio_path (Option<String>), profile_dir_accessible (bool), profile_dir_path (Option<String>), claude_api_key_set (bool), openai_api_key_set (bool)

    **src/components/sidebar.rs** -- Navigation sidebar:
    - Leptos component with BambuMate branding at top
    - Navigation links: Home ("/"), Settings ("/settings"), Health Check ("/health")
    - Use `<a>` tags with href for leptos_router navigation
    - Active state indication via CSS class (use leptos_router's current path if available, or simple CSS :active)
    - Clean, minimal styling -- this is a desktop app, not a website

    **src/app.rs** -- Root App component:
    - Wrap everything in `<Router>`
    - Layout: sidebar on the left (fixed width ~240px), main content area on the right
    - `<Routes>` with fallback for unknown paths
    - Route "/" -> HomePage
    - Route "/settings" -> SettingsPage
    - Route "/health" -> HealthPage
    - Use Leptos 0.8 imports: `use leptos::prelude::*;` and `use leptos_router::components::*;` and `use leptos_router::path;`

    **src/pages/home.rs** -- Home page:
    - Welcome message: "BambuMate" heading, brief description
    - Status summary cards (placeholder for now -- will show quick health status in future)
    - Quick action buttons (placeholder: "Search Filament", "Analyze Print", "View Profiles")

    **src/pages/settings.rs** -- Settings page (UI skeleton):
    - Page heading "Settings"
    - Section: "API Keys" with placeholder form fields for Claude API Key and OpenAI API Key
    - Each key field: text input (type="password"), Save button, status indicator (not set / saved)
    - Section: "Preferences" with placeholder for Bambu Studio path
    - The actual save/load logic will be wired in Plan 02 -- here just create the UI structure with signals for state
    - Use `leptos::spawn::spawn_local` pattern for async operations (shown in research)

    **src/pages/health.rs** -- Health check page (UI skeleton):
    - Page heading "Health Check"
    - "Run Health Check" button
    - Results display area (initially empty, shows results after button click)
    - Placeholder for status items: Bambu Studio, Profile Directory, Claude API Key, OpenAI API Key
    - Each status item: name, status icon (checkmark/x), detail text
    - Not yet wired to backend -- just the visual structure

    **style/main.css**:
    - App layout: flexbox, sidebar fixed width 240px, content fills remainder
    - Sidebar: dark background (#1e1e2e or similar), light text, vertical nav list
    - Content area: light background, padded
    - Form elements: basic input styling, buttons with hover states
    - Status badges: green for pass, red for fail, gray for unchecked
    - Responsive considerations not needed (desktop app, fixed minimum window size)
    - Keep styling minimal and clean -- this is Phase 1 foundation

    **src/pages/mod.rs**: Re-export all page components
    **src/components/mod.rs**: Re-export all component modules

    Update **src/main.rs** to import and mount the App component.
  </action>
  <verify>
    1. `cd /Users/michaelcurtis/Development/BambuMate && cargo check` succeeds
    2. Verify src/app.rs contains Router with three Route definitions
    3. Verify src/components/sidebar.rs contains navigation links to /, /settings, /health
    4. Verify src/commands.rs contains the wasm_bindgen invoke extern block
  </verify>
  <done>
    Frontend compiles. App component has Router with sidebar layout and three routed pages. Commands module provides typed invoke helpers for all backend operations. Pages have visual structure with placeholder content ready for wiring.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Tauri backend commands and verify app launches</name>
  <files>
    src-tauri/src/lib.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/commands/keychain.rs
    src-tauri/src/commands/config.rs
    src-tauri/src/commands/health.rs
    src-tauri/src/error.rs
  </files>
  <action>
    **src-tauri/src/error.rs** -- Backend error types:
    - Define `BambuMateError` enum using thiserror:
      - `Keychain(String)` -- keyring operation failures
      - `Config(String)` -- preference storage failures
      - `HealthCheck(String)` -- health check failures
    - Implement `Into<String>` or `Display` for use in Tauri command Result types
    - Tauri commands return `Result<T, String>` -- convert errors to String at the command boundary

    **src-tauri/src/commands/keychain.rs** -- Keychain commands:
    - `#[tauri::command] pub fn set_api_key(service: &str, key: &str) -> Result<(), String>`
      - Use `keyring::Entry::new(service, "bambumate")` to create entry
      - Call `entry.set_password(key)` to store in OS keychain
      - Map errors to String
    - `#[tauri::command] pub fn get_api_key(service: &str) -> Result<Option<String>, String>`
      - Create entry, call `get_password()`
      - Return `Ok(Some(password))` on success
      - Return `Ok(None)` on `keyring::Error::NoEntry`
      - Return `Err` on other errors
    - `#[tauri::command] pub fn delete_api_key(service: &str) -> Result<(), String>`
      - Create entry, call `delete_credential()`
      - Map errors to String
    - Service names: "bambumate-claude-api" for Claude, "bambumate-openai-api" for OpenAI (namespaced to avoid collisions)

    **src-tauri/src/commands/config.rs** -- Preference commands:
    - `#[tauri::command] pub fn get_preference(app: tauri::AppHandle, key: &str) -> Result<Option<String>, String>`
      - Use `app.store("preferences.json")` from tauri-plugin-store
      - Get value by key, return as Option<String>
    - `#[tauri::command] pub fn set_preference(app: tauri::AppHandle, key: &str, value: &str) -> Result<(), String>`
      - Use `app.store("preferences.json")`
      - Set key-value pair
      - Call `.save()` to persist
    - Non-sensitive preferences: bambu_studio_path, default_printer, window preferences

    **src-tauri/src/commands/health.rs** -- Health check command:
    - Define `HealthReport` struct with Serialize derive:
      - bambu_studio_installed: bool
      - bambu_studio_path: Option<String>
      - profile_dir_accessible: bool
      - profile_dir_path: Option<String>
      - claude_api_key_set: bool
      - openai_api_key_set: bool
    - `#[tauri::command] pub fn run_health_check() -> Result<HealthReport, String>`
      - Check Bambu Studio: `PathBuf::from("/Applications/BambuStudio.app").exists()`
      - Check profile directory: use `dirs::data_dir()` -> join appropriate Bambu Studio path. On macOS, Bambu Studio stores configs at `~/Library/Application Support/BambuStudio/` or similar. Check both common locations.
      - Check API keys: use `keyring::Entry::new("bambumate-claude-api", "bambumate").get_password().is_ok()` and same for openai
      - Return populated HealthReport

    **src-tauri/src/commands/mod.rs**: Re-export all command modules.

    **src-tauri/src/lib.rs** -- Wire everything together:
    - `mod commands;` and `mod error;`
    - Initialize tracing subscriber with env filter
    - Register tauri_plugin_store
    - Register all commands in generate_handler!:
      - commands::keychain::set_api_key
      - commands::keychain::get_api_key
      - commands::keychain::delete_api_key
      - commands::config::get_preference
      - commands::config::set_preference
      - commands::health::run_health_check

    **Verify the app launches:**
    - Run `cargo tauri dev` and confirm:
      1. The window opens with "BambuMate" title
      2. Sidebar navigation is visible
      3. Clicking navigation links switches between pages
      4. No console errors about __TAURI__ being undefined
    - If `cargo tauri dev` requires Trunk to be installed, install it first: `cargo install trunk`
    - If icons are missing, generate them: `cargo tauri icon` or create minimal placeholder PNGs

    **Important:** If `cargo tauri dev` fails due to missing system dependencies (e.g., webkit2gtk on Linux -- not applicable on macOS), document the issue. On macOS, Tauri uses the system WebKit so no extra deps should be needed.
  </action>
  <verify>
    1. `cd /Users/michaelcurtis/Development/BambuMate/src-tauri && cargo check` succeeds
    2. `cd /Users/michaelcurtis/Development/BambuMate && cargo tauri build --debug 2>&1 | tail -5` compiles without errors (use debug build for speed)
    3. Verify src-tauri/src/lib.rs contains all 6 commands in generate_handler!
    4. Verify src-tauri/src/commands/keychain.rs has set_api_key, get_api_key, delete_api_key functions
    5. Verify src-tauri/src/commands/health.rs has HealthReport struct and run_health_check function
  </verify>
  <done>
    Backend compiles with all Tauri commands registered. Keychain commands use keyring crate with apple-native feature. Health check detects Bambu Studio installation, profile directory, and API key status. Config commands use tauri-plugin-store for non-sensitive preferences. The app builds successfully (debug mode minimum).
  </done>
</task>

</tasks>

<verification>
1. Both crates compile: `cargo check` in root AND `cargo check` in src-tauri/
2. App structure matches research architecture (sidebar + routed pages)
3. tauri.conf.json has withGlobalTauri: true
4. Trunk.toml port matches tauri.conf.json devUrl (1420)
5. All 6 Tauri commands registered in generate_handler!
6. Frontend commands.rs has invoke helpers matching backend commands
7. `cargo tauri build --debug` succeeds (proves build pipeline works)
</verification>

<success_criteria>
- The Tauri + Leptos app compiles and builds without errors
- App shell has sidebar navigation with three routed pages (Home, Settings, Health)
- Backend commands exist for keychain (3), config (2), and health (1) operations
- Frontend has typed invoke helpers for all backend commands
- Build pipeline (Trunk + Tauri) is functional
</success_criteria>

<output>
After completion, create `.planning/phases/01-app-foundation/01-01-SUMMARY.md`
</output>
