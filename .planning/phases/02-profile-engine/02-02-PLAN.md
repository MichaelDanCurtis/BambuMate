---
phase: 02-profile-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src-tauri/src/profile/writer.rs
  - src-tauri/src/profile/mod.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/profile.rs
  - src-tauri/src/lib.rs
  - tests/fixtures/sample_profile.json
  - tests/fixtures/sample_profile.info
  - src-tauri/tests/profile_tests.rs
autonomous: true

must_haves:
  truths:
    - "A profile read from disk and written back produces byte-identical JSON (same keys, same order, same 4-space indent, same trailing newline)"
    - "Writing a profile is atomic -- an interrupted write leaves the original file intact, never a partial file"
    - "The .info companion file is written atomically alongside the profile JSON"
    - "All 139+ fields survive a round-trip without any being dropped or modified"
    - "nil string values are preserved exactly as-is through read-write cycle"
    - "Dual-extruder 2-element arrays are preserved through read-write cycle"
    - "Profile Tauri commands are registered and callable from the frontend"
  artifacts:
    - path: "src-tauri/src/profile/writer.rs"
      provides: "Atomic profile write with 4-space JSON formatting"
      contains: "pub fn write_profile_atomic"
    - path: "src-tauri/src/commands/profile.rs"
      provides: "Tauri commands for profile operations"
      contains: "#[tauri::command]"
    - path: "src-tauri/tests/profile_tests.rs"
      provides: "Integration tests for round-trip, nil preservation, atomic write"
      contains: "fn test_round_trip"
    - path: "tests/fixtures/sample_profile.json"
      provides: "Real Bambu Studio profile fixture for testing"
      min_lines: 50
  key_links:
    - from: "src-tauri/src/profile/writer.rs"
      to: "tempfile::NamedTempFile"
      via: "persist() for atomic rename"
      pattern: "NamedTempFile.*persist"
    - from: "src-tauri/src/profile/writer.rs"
      to: "src-tauri/src/profile/types.rs"
      via: "serializes FilamentProfile with 4-space PrettyFormatter"
      pattern: "PrettyFormatter::with_indent"
    - from: "src-tauri/src/commands/profile.rs"
      to: "src-tauri/src/profile/mod.rs"
      via: "commands call profile module functions"
      pattern: "profile::"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/profile.rs"
      via: "commands registered in generate_handler!"
      pattern: "commands::profile::"
---

<objective>
Create the profile writer with atomic writes, wire Tauri commands for profile operations, and build integration tests proving round-trip fidelity.

Purpose: This completes the profile engine. After this plan, BambuMate can read any Bambu Studio profile, write it back without data loss, and expose these operations to the frontend. The round-trip guarantee is the critical property -- if a read-then-write changes even one field or one whitespace character, Bambu Studio may reject the profile or cloud sync may fight it.

Output: A `writer` module with atomic write using tempfile, Tauri commands for profile listing/reading/writing, and integration tests proving round-trip fidelity with a real profile fixture.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-profile-engine/02-RESEARCH.md

# Plan 01 SUMMARY will exist by execution time
@.planning/phases/02-profile-engine/02-01-SUMMARY.md

# Files created by Plan 01 that this plan depends on
@src-tauri/src/profile/mod.rs
@src-tauri/src/profile/types.rs
@src-tauri/src/profile/paths.rs
@src-tauri/src/profile/reader.rs
@src-tauri/src/profile/registry.rs
@src-tauri/src/profile/inheritance.rs
@src-tauri/src/lib.rs
@src-tauri/src/error.rs
@src-tauri/src/commands/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile writer and test fixtures</name>
  <files>
    src-tauri/src/profile/writer.rs
    src-tauri/src/profile/mod.rs
    tests/fixtures/sample_profile.json
    tests/fixtures/sample_profile.info
    src-tauri/tests/profile_tests.rs
  </files>
  <action>
**profile/writer.rs -- Atomic write functions:**

- `write_profile_atomic(profile: &FilamentProfile, target_path: &Path) -> Result<()>`:
  1. Serialize the profile using `to_json_4space()` (the 4-space formatter from types.rs).
  2. Get parent directory from target_path. Create it with `std::fs::create_dir_all` if it doesn't exist.
  3. Create `tempfile::NamedTempFile::new_in(parent_dir)` -- temp file MUST be in same directory for atomic rename on same filesystem.
  4. Write JSON bytes to temp file via `std::io::Write`.
  5. Call `temp.flush()` then `temp.persist(target_path)?` for the atomic rename.
  6. Log with `tracing::info!("Wrote profile to {:?}", target_path)`.

- `write_profile_metadata_atomic(metadata: &ProfileMetadata, target_path: &Path) -> Result<()>`:
  1. Serialize metadata using `to_info_string()`.
  2. Same atomic write pattern: NamedTempFile in same directory, write, flush, persist.

- `write_profile_with_metadata(profile: &FilamentProfile, json_path: &Path, metadata: &ProfileMetadata) -> Result<()>`:
  1. Write the profile JSON atomically.
  2. Compute the .info path: `json_path.with_extension("info")`.
  3. Write the metadata atomically.
  4. If the metadata write fails, log a warning but don't try to rollback the JSON write (the JSON is valid on its own; better to have a valid profile with stale metadata than to delete a good profile).

**Update profile/mod.rs:**
- Add `pub mod writer;` to the module declarations.
- Add `pub use writer::write_profile_atomic;` to the convenience re-exports.

**Test fixtures:**
Create `tests/fixtures/` directory at the project root (alongside src-tauri).

- `tests/fixtures/sample_profile.json`: Create a realistic user profile fixture. It should be a JSON object with:
  - Identity fields: `name`, `inherits` (empty string), `filament_id`, `from` ("User"), `version`
  - At least 30 array fields including: `nozzle_temperature`, `nozzle_temperature_initial_layer`, `bed_temperature`, `filament_type`, `filament_flow_ratio`, `filament_retraction_length`, `filament_retraction_speed`, `fan_cooling_layer_time`, `fan_max_speed`, `fan_min_speed`, `compatible_printers`, `compatible_prints`, `filament_start_gcode`, `filament_end_gcode`
  - Include some `"nil"` values: e.g., `"filament_retraction_minimum_travel": ["nil", "nil"]`
  - Include 2-element arrays for dual-extruder: e.g., `"nozzle_temperature": ["220", "220"]`
  - Include an empty array: `"compatible_prints": []`
  - Include percentage strings: `"fan_max_speed": ["80%", "80%"]`
  - Use 4-space indentation and alphabetical key ordering (matching real user profile format)
  - End with a trailing newline
  - Aim for ~50 fields total to be realistic

- `tests/fixtures/sample_profile.info`: Create matching .info file:
  ```
  sync_info =
  user_id = 1881310893
  setting_id = PFUS50d8c9d5139548
  base_id =
  updated_time = 1770267863
  ```

**Integration tests (src-tauri/tests/profile_tests.rs):**
This is a Rust integration test file (in src-tauri/tests/ directory, using `#[cfg(test)]` is NOT needed since it's in the tests/ dir).

Important: The test file needs access to the profile module. Use `use bambumate_tauri::profile::*;` (the crate name from Cargo.toml is `bambumate-tauri` which becomes `bambumate_tauri` in Rust).

Wait -- check if lib.rs makes the profile module public. It needs `pub mod profile;` in lib.rs for integration tests to access it. Plan 01 creates `mod profile;` -- this task must change it to `pub mod profile;` in lib.rs if it's not already pub.

Tests to write:

1. `test_round_trip_preserves_all_fields`: Read sample_profile.json, write it via to_json_4space(), parse the output, assert field count is identical, assert every field has identical value.

2. `test_round_trip_byte_identical`: Read the raw fixture file as a string, parse into FilamentProfile, serialize with to_json_4space(), assert the output string equals the input string exactly (byte-for-byte). This is the gold standard test.

3. `test_nil_values_preserved`: Read fixture, check that fields with "nil" values still contain "nil" after round-trip. Specifically verify the array ["nil", "nil"] pattern.

4. `test_dual_extruder_arrays_preserved`: Read fixture, verify 2-element arrays maintain their length after round-trip.

5. `test_metadata_round_trip`: Read sample_profile.info, parse into ProfileMetadata, serialize back, compare strings.

6. `test_atomic_write_creates_file`: Write a profile to a temp directory, verify the file exists and is valid JSON.

7. `test_atomic_write_with_metadata`: Write profile + metadata, verify both files exist.

For the fixture path in tests, use `std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR")).parent().unwrap().join("tests/fixtures/sample_profile.json")` -- since CARGO_MANIFEST_DIR points to src-tauri/ and fixtures are at the project root's tests/ directory.

Actually, simpler: put fixtures at `src-tauri/tests/fixtures/` instead. Then use `PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/sample_profile.json")`. Move the fixture files to `src-tauri/tests/fixtures/` rather than the project root.
  </action>
  <verify>
Run `cargo test -p bambumate-tauri -- profile` to execute all profile-related tests. All 7 tests must pass. The byte-identical round-trip test is the most critical -- if it fails, the profile engine cannot be trusted.
  </verify>
  <done>
- write_profile_atomic uses tempfile::NamedTempFile::persist() for crash-safe writes
- write_profile_with_metadata writes both .json and .info atomically
- Test fixture contains realistic profile with nil values, dual arrays, percentages
- test_round_trip_byte_identical passes: read -> write produces identical bytes
- test_nil_values_preserved passes: "nil" strings survive round-trip
- test_dual_extruder_arrays_preserved passes: 2-element arrays maintain length
- test_metadata_round_trip passes: .info format survives round-trip
- test_atomic_write_creates_file passes: file written to temp dir successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Tauri commands for profile operations</name>
  <files>
    src-tauri/src/commands/profile.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/lib.rs
  </files>
  <action>
**commands/profile.rs -- Tauri commands:**

Create profile commands that expose the profile engine to the frontend. These commands will be used in future phases for the UI.

1. `list_profiles() -> Result<Vec<ProfileInfo>, String>`:
   - Call `BambuPaths::detect()`. If it fails, return empty vec (not error -- Bambu Studio may not be installed).
   - Scan user filament directory (via `BambuPaths::user_filament_dir()`).
   - For each .json file found, read the profile and extract: name, filament_type, filament_id, file path.
   - Return a `Vec<ProfileInfo>` where `ProfileInfo` is a serializable struct with: `name: String`, `filament_type: Option<String>`, `filament_id: Option<String>`, `path: String`, `is_user_profile: bool`.
   - Sort results alphabetically by name.
   - Log count with tracing::info.

2. `read_profile_command(path: String) -> Result<ProfileDetail, String>`:
   - Read the profile from the given path.
   - Read metadata if .info file exists.
   - Return a `ProfileDetail` struct with: `name: Option<String>`, `filament_type: Option<String>`, `filament_id: Option<String>`, `inherits: Option<String>`, `field_count: usize`, `nozzle_temperature: Option<Vec<String>>`, `bed_temperature: Option<Vec<String>>`, `compatible_printers: Option<Vec<String>>`, `metadata: Option<ProfileMetadataInfo>`, `raw_json: String` (the full JSON string for display/debugging).
   - `ProfileMetadataInfo` is a serializable struct mirroring ProfileMetadata fields.

3. `get_system_profile_count() -> Result<usize, String>`:
   - Quick check: call BambuPaths::detect(), count .json files in system_filaments directory using walkdir.
   - Returns the count. Useful for health check and UI.

Define the response structs (`ProfileInfo`, `ProfileDetail`, `ProfileMetadataInfo`) in the same file with `#[derive(Debug, Clone, Serialize)]`.

Error handling: Convert all anyhow errors to String at the Tauri boundary using `.map_err(|e| e.to_string())`.

**commands/mod.rs:**
- Add `pub mod profile;` to the module list.

**lib.rs:**
- Ensure `mod profile;` is `pub mod profile;` (needed for integration tests).
- Add the three new commands to `generate_handler![]`:
  ```
  commands::profile::list_profiles,
  commands::profile::read_profile_command,
  commands::profile::get_system_profile_count,
  ```
  </action>
  <verify>
Run `cargo check -p bambumate-tauri` -- must compile with zero errors. Run `cargo test -p bambumate-tauri` -- all tests from Task 1 still pass. The Tauri commands are registered and will be callable from the frontend (manual verification deferred to future phases that build the UI).
  </verify>
  <done>
- Three Tauri commands registered: list_profiles, read_profile_command, get_system_profile_count
- list_profiles scans user filament directory and returns profile summaries
- read_profile_command reads a single profile with metadata and returns full detail
- get_system_profile_count returns count of system profiles
- All response types are properly serializable for Tauri IPC
- All existing tests still pass
- cargo check passes with zero errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo check -p bambumate-tauri` passes with zero errors
2. `cargo test -p bambumate-tauri` passes -- all 7+ profile tests green
3. The byte-identical round-trip test is the single most important test: `test_round_trip_byte_identical`
4. lib.rs has all 10 commands registered in generate_handler (7 from Phase 1 + 3 new)
5. Profile writer uses tempfile::NamedTempFile::persist() (not raw fs::write)
6. JSON output uses 4-space indentation (not 2-space default)

Build verification:
- `cargo tauri build --debug` should still succeed (the profile module is pure Rust, no WASM implications)
</verification>

<success_criteria>
- Atomic profile writes via tempfile persist -- crash mid-write never corrupts
- Round-trip fidelity: read -> write produces byte-identical output for user profiles
- All 139+ fields preserved including nil values, dual-extruder arrays, percentages
- .info metadata files handled (parse and write)
- Three Tauri commands expose profile operations to the frontend
- Integration test suite validates all critical properties
</success_criteria>

<output>
After completion, create `.planning/phases/02-profile-engine/02-02-SUMMARY.md`
</output>
