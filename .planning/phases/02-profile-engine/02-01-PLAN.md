---
phase: 02-profile-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/error.rs
  - src-tauri/src/profile/mod.rs
  - src-tauri/src/profile/types.rs
  - src-tauri/src/profile/paths.rs
  - src-tauri/src/profile/reader.rs
  - src-tauri/src/profile/inheritance.rs
  - src-tauri/src/profile/registry.rs
autonomous: true

must_haves:
  truths:
    - "FilamentProfile can be constructed from any Bambu Studio profile JSON string without losing fields"
    - "BambuPaths::detect() finds the real Bambu Studio config directory on macOS"
    - "BambuPaths can locate both system filament profiles and user filament profiles"
    - "ProfileRegistry can discover and index all system profiles via walkdir"
    - "Inheritance resolution walks the inherits chain and merges fields from base to leaf"
    - "The string nil is treated as inherit-from-parent during resolution, not as a real value"
  artifacts:
    - path: "src-tauri/src/profile/types.rs"
      provides: "FilamentProfile, ProfileMetadata, ProfileId types"
      contains: "pub struct FilamentProfile"
    - path: "src-tauri/src/profile/paths.rs"
      provides: "BambuPaths with OS-specific detection"
      contains: "pub fn detect"
    - path: "src-tauri/src/profile/reader.rs"
      provides: "read_profile and read_profile_metadata"
      contains: "pub fn read_profile"
    - path: "src-tauri/src/profile/inheritance.rs"
      provides: "resolve_inheritance function"
      contains: "pub fn resolve_inheritance"
    - path: "src-tauri/src/profile/registry.rs"
      provides: "ProfileRegistry with discovery and lookup"
      contains: "pub struct ProfileRegistry"
  key_links:
    - from: "src-tauri/src/profile/inheritance.rs"
      to: "src-tauri/src/profile/registry.rs"
      via: "resolve_inheritance takes &ProfileRegistry to find parent profiles"
      pattern: "registry.*get_by_name"
    - from: "src-tauri/src/profile/registry.rs"
      to: "src-tauri/src/profile/reader.rs"
      via: "Registry uses reader to load profiles during discovery"
      pattern: "reader::read_profile"
    - from: "src-tauri/src/profile/paths.rs"
      to: "BambuStudio.conf"
      via: "reads preset_folder from config JSON"
      pattern: "preset_folder"
---

<objective>
Create the profile engine's core types, OS path detection, profile reader, profile registry, and inheritance resolution system.

Purpose: This is the foundation for all Bambu Studio profile operations. Every future phase (generation, installation, editing, diffing) depends on being able to read profiles from disk, resolve their inheritance chains, and access their fields in a type-safe way while preserving ALL unknown fields for round-trip fidelity.

Output: A `profile` module with 5 submodules (types, paths, reader, inheritance, registry) that can discover, read, and resolve any Bambu Studio filament profile on the local machine.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-profile-engine/02-RESEARCH.md

# Existing code to modify/extend
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src-tauri/src/error.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/commands/health.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile types, path detection, and reader modules</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/error.rs
    src-tauri/src/lib.rs
    src-tauri/src/profile/mod.rs
    src-tauri/src/profile/types.rs
    src-tauri/src/profile/paths.rs
    src-tauri/src/profile/reader.rs
  </files>
  <action>
**Dependencies (Cargo.toml):**
- Change existing `serde_json = "1.0"` to `serde_json = { version = "1.0", features = ["preserve_order"] }` -- this enables IndexMap-backed Map for key ordering preservation.
- Add `walkdir = "2.5"` and `tempfile = "3.24"` (tempfile added now so Plan 02 doesn't need to modify Cargo.toml).

**Error types (error.rs):**
- Add a `Profile(String)` variant to `BambuMateError` enum with `#[error("Profile error: {0}")]`.

**Module wiring (lib.rs):**
- Add `mod profile;` to lib.rs (after `mod error;`). No Tauri commands registered yet -- this plan is pure library code.

**profile/mod.rs:**
- Re-export the public API: `pub mod types; pub mod paths; pub mod reader; pub mod inheritance; pub mod registry;`
- Also re-export key types for convenience: `pub use types::{FilamentProfile, ProfileMetadata}; pub use paths::BambuPaths; pub use registry::ProfileRegistry;`

**profile/types.rs -- FilamentProfile:**
- Struct wrapping `serde_json::Map<String, Value>` as `data` field.
- `from_json(json: &str) -> Result<Self>`: Parse JSON string into Map. Use `serde_json::from_str`.
- `to_json_4space(&self) -> Result<String>`: Serialize with 4-space indentation using `serde_json::ser::PrettyFormatter::with_indent(b"    ")` and `Serializer::with_formatter`. Append trailing newline if not present. This is critical -- Bambu Studio uses 4-space indent, NOT serde_json's default 2-space.
- Typed accessors (all return Option): `name()`, `inherits()`, `filament_id()`, `filament_type()`, `nozzle_temperature()`, `compatible_printers()`, `setting_id()`, `filament_settings_id()`.
- Helper: `get_first_array_value(key) -> Option<&str>` for single-value array fields.
- Helper: `get_string_array(key) -> Option<Vec<&str>>` for multi-value array fields.
- Mutators: `set_string(key, value)`, `set_string_array(key, values: Vec<String>)`.
- Raw access: `raw() -> &Map<String, Value>`, `raw_mut() -> &mut Map<String, Value>`.
- `field_count() -> usize` for testing.

**profile/types.rs -- ProfileMetadata (.info file):**
- Struct with fields: `sync_info: String`, `user_id: String`, `setting_id: String`, `base_id: String`, `updated_time: u64`.
- Implement `Default` trait (empty strings, 0 for updated_time).
- `to_info_string(&self) -> String`: Format as INI-like format matching Bambu Studio's output: `"sync_info = {}\nuser_id = {}\nsetting_id = {}\nbase_id = {}\nupdated_time = {}\n"`.
- `from_info_string(content: &str) -> Result<Self>`: Parse by splitting each line on ` = ` (space-equals-space). Handle missing fields gracefully. Ignore unknown fields.

**profile/paths.rs -- BambuPaths:**
- Struct with fields: `config_root: PathBuf`, `system_filaments: PathBuf`, `user_root: PathBuf`, `preset_folder: Option<String>`.
- `detect() -> Result<Self>`: Use `dirs::data_dir()` to find `~/Library/Application Support/BambuStudio/`. Fallback: `dirs::home_dir().join("Library/Application Support/BambuStudio")`. If neither exists, return error.
- Set `system_filaments` = config_root.join("system/BBL/filament").
- Set `user_root` = config_root.join("user").
- Read `preset_folder` from `BambuStudio.conf` (JSON file at config_root/BambuStudio.conf). Parse as `serde_json::Value`, extract `preset_folder` string field. If file missing or field missing, `preset_folder = None`.
- `user_filament_dir(&self) -> Option<PathBuf>`: If preset_folder is Some, check `user_root/{preset_folder}/filament/base/`. If that exists, return it. Fallback: scan user_root for non-"default" directories that have a `filament/base/` subdirectory.
- `system_filament_dir(&self) -> PathBuf`: Returns system_filaments path.
- Add `#[cfg(target_os = "windows")]` and `#[cfg(target_os = "linux")]` stubs for future cross-platform support (return "not supported" error for now, but the struct is platform-agnostic).

**profile/reader.rs:**
- `read_profile(path: &Path) -> Result<FilamentProfile>`: Read file to string, call `FilamentProfile::from_json`. Log the profile name and field count with tracing::debug.
- `read_profile_metadata(json_path: &Path) -> Result<Option<ProfileMetadata>>`: Compute .info path by changing extension. If .info file exists, read and parse. If not, return Ok(None).

Use `anyhow::Result` for all error returns. Use `tracing::debug` / `tracing::warn` for logging.
  </action>
  <verify>
Run `cargo check -p bambumate-tauri` from the project root -- must compile with zero errors. Check that `preserve_order` feature is active by verifying `serde_json::Map` is an `IndexMap` (the import will compile only with preserve_order enabled).
  </verify>
  <done>
- FilamentProfile can parse any JSON object string and re-serialize with 4-space indent
- ProfileMetadata can parse and serialize .info INI format
- BambuPaths::detect() compiles and resolves macOS paths
- reader::read_profile and read_profile_metadata compile and use correct types
- All types are properly re-exported from profile/mod.rs
- Cargo.toml has serde_json with preserve_order, walkdir, and tempfile dependencies
  </done>
</task>

<task type="auto">
  <name>Task 2: Create profile registry and inheritance resolution</name>
  <files>
    src-tauri/src/profile/registry.rs
    src-tauri/src/profile/inheritance.rs
  </files>
  <action>
**profile/registry.rs -- ProfileRegistry:**
- Struct with `profiles: HashMap<String, FilamentProfile>` (keyed by profile name).
- `new() -> Self`: Empty registry.
- `discover_system_profiles(system_dir: &Path) -> Result<Self>`: Use `walkdir::WalkDir::new(system_dir)` to recursively find all `.json` files. For each file, read it via `reader::read_profile`, extract the `name` field, and insert into the HashMap. Log count with `tracing::info!("Discovered {} system profiles", count)`. Skip files that fail to parse (log warning, don't error) -- some files in the directory may not be filament profiles (e.g., BBL.json registry file). Filter: only include entries that have a `name` field (skip BBL.json which is a registry, not a profile).
- `discover_user_profiles(user_dir: &Path) -> Result<()>`: Similar walkdir but for user filament directory. Adds to existing registry. User profiles are in the `base/` subdirectory.
- `get_by_name(&self, name: &str) -> Option<&FilamentProfile>`: Look up profile by name.
- `insert(&mut self, profile: FilamentProfile)`: Insert profile using its name as key.
- `names(&self) -> Vec<&str>`: Return all profile names.
- `len(&self) -> usize`: Return count.

**profile/inheritance.rs -- resolve_inheritance:**
- `resolve_inheritance(profile: &FilamentProfile, registry: &ProfileRegistry) -> Result<FilamentProfile>`:
  1. Build inheritance chain: Start with profile, follow `inherits()` field to parent via `registry.get_by_name()`. Continue until `inherits()` is empty string or None. Guard against circular inheritance (keep a HashSet of visited names, error if cycle detected). Max depth of 10 (safety limit).
  2. Reverse the chain (base first, leaf last).
  3. Create a new empty `Map<String, Value>`.
  4. For each profile in the chain (base to leaf), merge its fields into the resolved map. When merging, skip metadata fields that should NOT be inherited: `inherits`, `name`, `type`, `from`, `instantiation`, `filament_id`, `setting_id`, `include`, `description`, `compatible_printers`, `compatible_prints`, `compatible_printers_condition`, `compatible_prints_condition`, `filament_settings_id`.
  5. After merging ancestors, apply ALL fields from the leaf profile (including metadata fields) -- the leaf's identity overrides everything.
  6. Handle `"nil"` values: During merge, if a field value is the string `"nil"` or is an array containing only `"nil"` strings (e.g., `["nil", "nil"]`), skip it -- do NOT overwrite the parent's real value with nil. This means "nil" = "I don't override this, use parent value."
  7. Return a new `FilamentProfile` from the resolved map.

- `is_nil_value(value: &Value) -> bool`: Helper that returns true if value is:
  - The string `"nil"`
  - An array where ALL elements are the string `"nil"` (e.g., `["nil"]`, `["nil", "nil"]`)

- `is_fully_flattened(profile: &FilamentProfile) -> bool`: Returns true if `inherits()` returns empty string or None. Useful for callers to skip resolution for user profiles that are already flattened.

Important: Do NOT handle the `include` field (mixin mechanism) in this plan. Include is used by system profiles for dual-extruder templates. It adds complexity and is not needed for the Phase 2 success criteria (which focus on reading user profiles and writing correct profiles). Log a tracing::debug message if a profile has an `include` field so we know it exists but don't resolve it.
  </action>
  <verify>
Run `cargo check -p bambumate-tauri` -- must compile with zero errors. Verify that all public functions in both modules are accessible via `profile::registry::ProfileRegistry` and `profile::inheritance::resolve_inheritance`.
  </verify>
  <done>
- ProfileRegistry can discover profiles from a directory tree using walkdir
- ProfileRegistry can look up profiles by name
- resolve_inheritance walks the inherits chain up to 10 levels
- resolve_inheritance merges fields from base to leaf, skipping metadata fields
- nil values are properly detected and skipped during inheritance merge
- Circular inheritance is detected and returns an error
- is_fully_flattened correctly identifies user profiles that need no resolution
- Entire profile module compiles cleanly
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo check -p bambumate-tauri` passes with zero errors and zero warnings (or only expected warnings)
2. The profile module is accessible from lib.rs
3. All 5 submodules (types, paths, reader, inheritance, registry) compile and their public types/functions are exported
4. Cargo.toml includes serde_json with preserve_order, walkdir 2.5, and tempfile 3.24

Manual verification (for reference, not blocking):
- BambuPaths::detect() should find the real Bambu Studio directory if installed
- ProfileRegistry::discover_system_profiles() should find 1000+ system profiles
</verification>

<success_criteria>
- Profile module exists with 5 submodules, all compiling cleanly
- FilamentProfile wraps serde_json::Map with typed accessors for key fields
- ProfileMetadata handles .info INI format (parse and serialize)
- BambuPaths resolves macOS paths including preset_folder from BambuStudio.conf
- ProfileRegistry discovers profiles via walkdir and provides name-based lookup
- Inheritance resolution walks the chain, merges base-to-leaf, handles nil correctly
- No data loss: FilamentProfile stores raw Map, not a typed struct
</success_criteria>

<output>
After completion, create `.planning/phases/02-profile-engine/02-01-SUMMARY.md`
</output>
