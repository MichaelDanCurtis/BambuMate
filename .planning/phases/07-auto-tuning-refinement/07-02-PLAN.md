---
phase: 07-auto-tuning-refinement
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src-tauri/src/commands/analyzer.rs
  - src-tauri/src/commands/history.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can apply selected recommendations to a profile with one command"
    - "Backup is automatically created before apply"
    - "User can list and view past analysis sessions for a profile"
    - "User can revert to a previous backup"
  artifacts:
    - path: "src-tauri/src/commands/history.rs"
      provides: "Tauri commands for history operations"
      exports: ["list_history_sessions", "get_history_session", "revert_to_backup"]
    - path: "src-tauri/src/commands/analyzer.rs"
      provides: "apply_recommendations command and updated AnalyzeResponse"
      contains: "pub async fn apply_recommendations"
  key_links:
    - from: "src-tauri/src/commands/analyzer.rs"
      to: "history::RefinementHistory"
      via: "record_analysis and record_apply calls"
      pattern: "history\\.record"
    - from: "src-tauri/src/commands/analyzer.rs"
      to: "profile::writer::backup_profile"
      via: "backup before apply"
      pattern: "backup_profile"
    - from: "src-tauri/src/commands/history.rs"
      to: "profile::writer::restore_from_backup"
      via: "revert command"
      pattern: "restore_from_backup"
    - from: "AnalyzeResponse"
      to: "frontend"
      via: "session_id field for apply flow"
      pattern: "session_id.*i64"
---

<objective>
Create Tauri commands for applying recommendations and managing refinement history. The apply command creates a backup, modifies the profile, and records the changes. History commands allow listing sessions and reverting to previous states.

Purpose: This wires the history store and backup functions from Plan 01 into user-invokable commands. The frontend can now offer "Apply Changes" and "View History" functionality.

Output: apply_recommendations command, history commands (list, get, revert), analyze_print modified to record sessions and return session_id in response.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-auto-tuning-refinement/07-RESEARCH.md
@.planning/phases/07-auto-tuning-refinement/07-01-PLAN.md
@src-tauri/src/commands/analyzer.rs
@src-tauri/src/profile/writer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create apply_recommendations command</name>
  <files>src-tauri/src/commands/analyzer.rs</files>
  <action>
Add apply_recommendations command to analyzer.rs:

**Request type:**
```rust
#[derive(Debug, Deserialize)]
pub struct ApplyRequest {
    pub profile_path: String,
    pub session_id: i64,
    pub selected_parameters: Vec<String>,  // User can deselect some
}
```

**Response type:**
```rust
#[derive(Debug, Serialize)]
pub struct ApplyResult {
    pub backup_path: String,
    pub changes_applied: Vec<crate::history::AppliedChange>,
    pub profile_path: String,
}
```

**Command implementation:**
```rust
#[tauri::command]
pub async fn apply_recommendations(
    app: tauri::AppHandle,
    request: ApplyRequest,
) -> Result<ApplyResult, String> {
    // 1. Get history store from Tauri state or create inline
    let data_dir = app.path().app_data_dir()
        .map_err(|e| format!("Failed to get data dir: {}", e))?;
    let db_path = data_dir.join("refinement_history.db");
    let history = RefinementHistory::new(&db_path)
        .map_err(|e| format!("Failed to open history: {}", e))?;

    // 2. Get the session to retrieve analysis results
    let session = history.get_session(request.session_id)?;
    let analysis: AnalyzeResponse = serde_json::from_str(&session.analysis_json)
        .map_err(|e| format!("Failed to parse analysis: {}", e))?;

    // 3. Create backup BEFORE any modification
    let profile_path = Path::new(&request.profile_path);
    let backup_path = crate::profile::writer::backup_profile(profile_path)
        .map_err(|e| format!("Failed to create backup: {}", e))?;

    // 4. Load current profile
    let profile = crate::profile::reader::read_profile(profile_path)
        .map_err(|e| format!("Failed to read profile: {}", e))?;

    // 5. Apply selected recommendations
    let mut data = profile.raw().clone();
    let mut changes: Vec<AppliedChange> = Vec::new();

    for rec in &analysis.recommendations {
        if !request.selected_parameters.contains(&rec.parameter) {
            continue;
        }

        // Format value for Bambu Studio (string in array)
        let formatted = format_value_for_profile(rec.recommended_value, &rec.parameter);
        data.insert(rec.parameter.clone(), serde_json::json!([formatted]));

        changes.push(AppliedChange {
            parameter: rec.parameter.clone(),
            old_value: rec.current_value,
            new_value: rec.recommended_value,
        });
    }

    let modified = FilamentProfile::from_map(data);

    // 6. Write modified profile atomically
    crate::profile::writer::write_profile_atomic(&modified, profile_path)
        .map_err(|e| format!("Failed to write profile: {}", e))?;

    // 7. Record apply in history
    history.record_apply(
        request.session_id,
        &changes,
        backup_path.to_string_lossy().as_ref(),
    )?;

    Ok(ApplyResult {
        backup_path: backup_path.to_string_lossy().to_string(),
        changes_applied: changes,
        profile_path: request.profile_path,
    })
}
```

**Helper function for value formatting:**
```rust
fn format_value_for_profile(value: f32, parameter: &str) -> String {
    match parameter {
        // Temperatures: integers
        "nozzle_temperature" | "cool_plate_temp" | "hot_plate_temp" |
        "textured_plate_temp" | "nozzle_temperature_initial_layer" => {
            format!("{:.0}", value)
        }
        // Percentages: integers
        "fan_min_speed" | "fan_max_speed" | "overhang_fan_speed" => {
            format!("{:.0}", value)
        }
        // Retraction length: 1 decimal
        "filament_retraction_length" => format!("{:.1}", value),
        // Speed: integers
        "filament_retraction_speed" => format!("{:.0}", value),
        // Flow/pressure: 2 decimals
        "filament_flow_ratio" | "pressure_advance" => format!("{:.2}", value),
        _ => format!("{}", value)
    }
}
```

Add necessary imports at top: use crate::history::{AppliedChange, RefinementHistory}; use std::path::Path;
  </action>
  <verify>
`cargo check -p bambumate` passes.
  </verify>
  <done>
apply_recommendations command accepts session_id + selected params, creates backup, modifies profile, records changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create history Tauri commands</name>
  <files>
    src-tauri/src/commands/history.rs
    src-tauri/src/commands/mod.rs
  </files>
  <action>
Create commands/history.rs with three commands:

```rust
//! Tauri commands for refinement history.

use serde::{Deserialize, Serialize};
use std::path::Path;

use crate::history::{RefinementHistory, SessionDetail, SessionSummary};

/// List all refinement sessions for a profile.
#[tauri::command]
pub async fn list_history_sessions(
    app: tauri::AppHandle,
    profile_path: String,
) -> Result<Vec<SessionSummary>, String> {
    let data_dir = app.path().app_data_dir()
        .map_err(|e| format!("Failed to get data dir: {}", e))?;
    let db_path = data_dir.join("refinement_history.db");

    let history = RefinementHistory::new(&db_path)
        .map_err(|e| format!("Failed to open history: {}", e))?;

    history.list_sessions(&profile_path)
}

/// Get full details of a refinement session.
#[tauri::command]
pub async fn get_history_session(
    app: tauri::AppHandle,
    session_id: i64,
) -> Result<SessionDetail, String> {
    let data_dir = app.path().app_data_dir()
        .map_err(|e| format!("Failed to get data dir: {}", e))?;
    let db_path = data_dir.join("refinement_history.db");

    let history = RefinementHistory::new(&db_path)
        .map_err(|e| format!("Failed to open history: {}", e))?;

    history.get_session(session_id)
}

/// Revert a profile to its state before a session's apply.
#[tauri::command]
pub async fn revert_to_backup(
    app: tauri::AppHandle,
    session_id: i64,
) -> Result<String, String> {
    let data_dir = app.path().app_data_dir()
        .map_err(|e| format!("Failed to get data dir: {}", e))?;
    let db_path = data_dir.join("refinement_history.db");

    let history = RefinementHistory::new(&db_path)
        .map_err(|e| format!("Failed to open history: {}", e))?;

    let session = history.get_session(session_id)?;

    let backup_path = session.backup_path
        .ok_or("No backup exists for this session")?;

    let profile_path = Path::new(&session.profile_path);
    let backup = Path::new(&backup_path);

    if !backup.exists() {
        return Err(format!("Backup file not found: {}", backup_path));
    }

    crate::profile::writer::restore_from_backup(backup, profile_path)
        .map_err(|e| format!("Failed to restore: {}", e))?;

    Ok(format!("Restored profile from {}", backup_path))
}
```

Update commands/mod.rs to add:
```rust
pub mod history;
```
  </action>
  <verify>
`cargo check -p bambumate` passes.
  </verify>
  <done>
History commands exist: list_history_sessions, get_history_session, revert_to_backup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update AnalyzeResponse with session_id and register commands</name>
  <files>
    src-tauri/src/lib.rs
    src-tauri/src/commands/analyzer.rs
  </files>
  <action>
**CRITICAL: Update AnalyzeResponse type** to include session_id so frontend can use it for apply flow:

In analyzer.rs, modify AnalyzeResponse:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalyzeResponse {
    pub defect_report: DefectReport,
    pub recommendations: Vec<Recommendation>,
    pub conflicts: Vec<Conflict>,
    pub current_values: std::collections::HashMap<String, String>,
    pub material_type: String,
    pub session_id: Option<i64>,  // NEW: Session ID for apply flow
}
```

**In analyzer.rs**, modify analyze_print to record sessions and return session_id:

After the analysis succeeds but before returning, update to:
```rust
// Record analysis session in history
let data_dir = app.path().app_data_dir()
    .map_err(|e| format!("Failed to get data dir: {}", e))?;
let db_path = data_dir.join("refinement_history.db");

let mut session_id: Option<i64> = None;

if let Ok(history) = RefinementHistory::new(&db_path) {
    // Profile path or "no_profile" for material-only analysis
    let profile_for_history = request.profile_path.clone()
        .unwrap_or_else(|| "no_profile".to_string());

    // Build response JSON for storage (without session_id to avoid recursion)
    let analysis_for_storage = serde_json::json!({
        "defect_report": defect_report,
        "recommendations": recommendations,
        "conflicts": evaluation.conflicts,
        "current_values": current_values,
        "material_type": material_type,
    });
    let analysis_json = serde_json::to_string(&analysis_for_storage).unwrap_or_default();

    // Don't store full image - only store if profile was provided
    let image_for_history = if request.profile_path.is_some() {
        Some(request.image_base64.as_str())
    } else {
        None  // Skip image storage for profile-less analysis
    };

    match history.record_analysis(&profile_for_history, image_for_history, &analysis_json) {
        Ok(id) => {
            session_id = Some(id);
            info!("Recorded analysis session {}", id);
        }
        Err(e) => {
            warn!("Failed to record analysis history: {}", e);
            // Non-fatal - don't fail the analysis
        }
    }
}

// Return response WITH session_id
Ok(AnalyzeResponse {
    defect_report,
    recommendations,
    conflicts: evaluation.conflicts,
    current_values,
    material_type,
    session_id,  // Include session ID for frontend apply flow
})
```

**In lib.rs**, add the new commands to invoke_handler:
- commands::analyzer::apply_recommendations
- commands::history::list_history_sessions
- commands::history::get_history_session
- commands::history::revert_to_backup

Add imports: use crate::history::RefinementHistory;
  </action>
  <verify>
`cargo check -p bambumate` passes.
`cargo build -p bambumate` completes.
Run `cargo test -p bambumate` - all tests pass.
  </verify>
  <done>
AnalyzeResponse includes session_id field.
analyze_print records session and returns session_id.
4 new commands registered in Tauri handler.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p bambumate` - no errors
2. `cargo test -p bambumate` - all tests pass
3. Commands in invoke_handler: apply_recommendations, list_history_sessions, get_history_session, revert_to_backup
4. AnalyzeResponse includes session_id: Option<i64>
5. analyze_print records sessions and returns session_id
</verification>

<success_criteria>
- AnalyzeResponse type includes session_id field
- analyze_print returns session_id in response for frontend use
- apply_recommendations creates backup, applies changes, records to history
- list_history_sessions returns sessions for a profile path
- get_history_session returns full session with analysis JSON
- revert_to_backup restores profile from backup
</success_criteria>

<output>
After completion, create `.planning/phases/07-auto-tuning-refinement/07-02-SUMMARY.md`
</output>
