---
phase: 07-auto-tuning-refinement
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/components/defect_report.rs
  - src/components/change_preview.rs
  - src/components/mod.rs
  - src/pages/print_analysis.rs
  - src/commands.rs
  - styles/change_preview.css
autonomous: true

must_haves:
  truths:
    - "User can click Apply Changes to modify their profile"
    - "User can select/deselect individual recommendations before applying"
    - "User sees confirmation dialog with before/after comparison"
  artifacts:
    - path: "src/components/change_preview.rs"
      provides: "ChangePreview dialog component"
      min_lines: 80
    - path: "src/components/defect_report.rs"
      provides: "Apply Changes button in recommendations section"
      contains: "Apply Changes"
    - path: "src/pages/print_analysis.rs"
      provides: "Apply flow integration"
      contains: "ChangePreview"
    - path: "src/commands.rs"
      provides: "Frontend apply_recommendations wrapper"
      contains: "apply_recommendations"
  key_links:
    - from: "src/components/change_preview.rs"
      to: "src/commands.rs::apply_recommendations"
      via: "invoke on confirm"
      pattern: "apply_recommendations"
    - from: "src/pages/print_analysis.rs"
      to: "src/components/change_preview.rs"
      via: "modal dialog"
      pattern: "ChangePreview"
    - from: "src/pages/print_analysis.rs"
      to: "AnalyzeResponse.session_id"
      via: "extract session_id from response"
      pattern: "session_id"
---

<objective>
Build the ChangePreview dialog component and integrate the apply flow into the print analysis page. Users can select which changes to apply and see before/after comparisons.

Purpose: This creates the "Apply Changes" user experience. After analysis, users can one-click apply changes with confirmation.

Output: ChangePreview dialog, Apply button in DefectReportDisplay, integrated into print_analysis page with session_id extraction from response.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-auto-tuning-refinement/07-RESEARCH.md
@.planning/phases/07-auto-tuning-refinement/07-02-PLAN.md
@src/components/defect_report.rs
@src/pages/print_analysis.rs
@src/commands.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChangePreview dialog component</name>
  <files>
    src/components/change_preview.rs
    src/components/mod.rs
    styles/change_preview.css
  </files>
  <action>
Create a modal dialog for previewing and confirming changes before apply:

**change_preview.rs:**
```rust
//! Change preview dialog for applying recommendations.

use leptos::prelude::*;
use crate::pages::print_analysis::RecommendationDisplay;

/// Dialog for previewing and confirming parameter changes.
#[component]
pub fn ChangePreview(
    recommendations: Vec<RecommendationDisplay>,
    profile_path: String,
    on_apply: Callback<Vec<String>>,  // selected params
    on_cancel: Callback<()>,
) -> impl IntoView {
    // Track which recommendations are selected (all by default)
    let (selected, set_selected) = signal(
        recommendations.iter().map(|r| r.parameter.clone()).collect::<Vec<_>>()
    );

    let toggle_param = move |param: String| {
        set_selected.update(|s| {
            if s.contains(&param) {
                s.retain(|p| p != &param);
            } else {
                s.push(param);
            }
        });
    };

    let confirm_apply = move |_| {
        on_apply.call(selected.get());
    };

    view! {
        <div class="change-preview-overlay">
            <style>{include_str!("change_preview.css")}</style>
            <div class="change-preview-dialog">
                <h3>"Apply Recommended Changes"</h3>
                <p class="dialog-subtitle">
                    "Select which changes to apply. A backup will be created automatically."
                </p>
                <p class="dialog-profile">
                    "Profile: " <code>{profile_path.clone()}</code>
                </p>

                <div class="changes-list">
                    {recommendations.iter().map(|rec| {
                        let param = rec.parameter.clone();
                        let param_for_toggle = param.clone();
                        let param_for_check = param.clone();
                        let label = rec.parameter_label.clone();
                        let change = rec.change_display.clone();
                        let rationale = rec.rationale.clone();

                        view! {
                            <div class="change-item">
                                <label class="change-checkbox">
                                    <input
                                        type="checkbox"
                                        checked=move || selected.get().contains(&param_for_check)
                                        on:change=move |_| toggle_param(param_for_toggle.clone())
                                    />
                                    <div class="change-details">
                                        <span class="param-label">{label}</span>
                                        <span class="change-arrow">{change}</span>
                                    </div>
                                </label>
                                <p class="change-rationale">{rationale}</p>
                            </div>
                        }
                    }).collect::<Vec<_>>()}
                </div>

                <div class="dialog-actions">
                    <button class="btn btn-secondary" on:click=move |_| on_cancel.call(())>
                        "Cancel"
                    </button>
                    <button
                        class="btn btn-primary"
                        on:click=confirm_apply
                        disabled=move || selected.get().is_empty()
                    >
                        {move || format!("Apply {} Changes", selected.get().len())}
                    </button>
                </div>
            </div>
        </div>
    }
}
```

**change_preview.css:** Modal overlay, dialog box, checkbox styling, change-item layout with before/after values, action buttons at bottom. Use existing BambuMate dark theme colors.

Update components/mod.rs to export: `pub mod change_preview;`
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
ChangePreview component renders as overlay dialog with selectable changes and Apply/Cancel buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add frontend command wrappers and types</name>
  <files>src/commands.rs</files>
  <action>
**Add types for apply flow at top of commands.rs:**
```rust
#[derive(Debug, Clone, Deserialize)]
pub struct ApplyResult {
    pub backup_path: String,
    pub changes_applied: Vec<AppliedChange>,
    pub profile_path: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct AppliedChange {
    pub parameter: String,
    pub old_value: f32,
    pub new_value: f32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SessionSummary {
    pub id: i64,
    pub created_at: String,
    pub was_applied: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SessionDetail {
    pub id: i64,
    pub profile_path: String,
    pub created_at: String,
    pub analysis_json: String,
    pub applied_changes: Option<Vec<AppliedChange>>,
    pub backup_path: Option<String>,
}
```

**CRITICAL: Update AnalyzeResponse type** to include session_id (matching backend change from Plan 02):
```rust
#[derive(Debug, Clone, Deserialize)]
pub struct AnalyzeResponse {
    pub defect_report: DefectReport,
    pub recommendations: Vec<Recommendation>,
    pub conflicts: Vec<Conflict>,
    pub current_values: std::collections::HashMap<String, String>,
    pub material_type: String,
    pub session_id: Option<i64>,  // NEW: Session ID for apply flow
}
```

**Add command wrappers:**
```rust
/// Apply recommended changes to a profile.
pub async fn apply_recommendations(
    profile_path: String,
    session_id: i64,
    selected_parameters: Vec<String>,
) -> Result<ApplyResult, String> {
    #[derive(Serialize)]
    struct Args {
        request: ApplyRequest,
    }
    #[derive(Serialize)]
    struct ApplyRequest {
        profile_path: String,
        session_id: i64,
        selected_parameters: Vec<String>,
    }

    invoke::<_, ApplyResult>("apply_recommendations", Args {
        request: ApplyRequest {
            profile_path,
            session_id,
            selected_parameters,
        }
    }).await
}

/// List refinement sessions for a profile.
pub async fn list_history_sessions(profile_path: String) -> Result<Vec<SessionSummary>, String> {
    #[derive(Serialize)]
    struct Args { profile_path: String }
    invoke("list_history_sessions", Args { profile_path }).await
}

/// Get details of a specific session.
pub async fn get_history_session(session_id: i64) -> Result<SessionDetail, String> {
    #[derive(Serialize)]
    struct Args { session_id: i64 }
    invoke("get_history_session", Args { session_id }).await
}

/// Revert profile to a backup.
pub async fn revert_to_backup(session_id: i64) -> Result<String, String> {
    #[derive(Serialize)]
    struct Args { session_id: i64 }
    invoke("revert_to_backup", Args { session_id }).await
}
```
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
Frontend AnalyzeResponse includes session_id field.
Frontend commands wrap all 4 new Tauri commands.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Apply button to DefectReportDisplay and integrate into print_analysis</name>
  <files>
    src/components/defect_report.rs
    src/pages/print_analysis.rs
  </files>
  <action>
**Update DefectReportDisplay** to accept callbacks and show Apply button:

Change the component signature to accept optional callbacks:
```rust
#[component]
pub fn DefectReportDisplay(
    defect_report: DefectReport,
    recommendations: Vec<RecommendationDisplay>,
    conflicts: Vec<Conflict>,
    material_type: String,
    #[prop(optional)] profile_path: Option<String>,
    #[prop(optional)] on_apply_click: Option<Callback<()>>,
) -> impl IntoView
```

In the recommendations section, after the recommendations-list div, add:
```rust
// Apply button (only if profile_path provided and recommendations exist)
{(!recommendations.is_empty() && profile_path.is_some()).then(|| {
    let on_click = on_apply_click.clone();
    view! {
        <div class="apply-section">
            <button
                class="btn btn-primary apply-btn"
                on:click=move |_| {
                    if let Some(cb) = &on_click {
                        cb.call(());
                    }
                }
            >
                "Apply Changes to Profile"
            </button>
            <p class="apply-hint">"A backup will be created before any changes are made."</p>
        </div>
    }
})}
```

**Update print_analysis.rs** to integrate apply flow:

1. Add state for apply flow:
```rust
let (profile_path, set_profile_path) = signal::<Option<String>>(None);
let (show_apply_dialog, set_show_apply_dialog) = signal(false);
let (current_session_id, set_current_session_id) = signal::<Option<i64>>(None);
```

2. Add a profile path input in the Ready state (optional - user can browse for a profile):
```rust
<div class="profile-selector">
    <label>"Profile to update (optional):"</label>
    <input
        type="text"
        class="input"
        placeholder="/path/to/profile.json"
        on:input=move |ev| {
            let val = event_target_value(&ev);
            if val.is_empty() {
                set_profile_path.set(None);
            } else {
                set_profile_path.set(Some(val));
            }
        }
    />
</div>
```

3. **Extract session_id from AnalyzeResponse when analysis completes:**
When setting AnalysisState::Complete with the response, also store session_id:
```rust
// After successful analysis
set_current_session_id.set(response.session_id);
```

4. In AnalysisState::Complete, pass on_apply_click callback to DefectReportDisplay:
```rust
let on_apply = move || {
    set_show_apply_dialog.set(true);
};

<DefectReportDisplay
    defect_report=response.defect_report.clone()
    recommendations=response.recommendations.clone()
    conflicts=response.conflicts.clone()
    material_type=response.material_type.clone()
    profile_path=profile_path.get()
    on_apply_click=Some(Callback::new(move |_| on_apply()))
/>
```

5. Show ChangePreview dialog when show_apply_dialog is true:
```rust
{move || show_apply_dialog.get().then(|| {
    let recs = /* get recommendations from current state */;
    let path = profile_path.get().unwrap_or_default();
    view! {
        <ChangePreview
            recommendations=recs
            profile_path=path.clone()
            on_apply=Callback::new(move |selected: Vec<String>| {
                // Call apply_recommendations using session_id from state
                let session = current_session_id.get();
                let p = path.clone();
                spawn_local(async move {
                    if let Some(sid) = session {
                        match commands::apply_recommendations(p, sid, selected).await {
                            Ok(result) => {
                                // Show success, close dialog
                                web_sys::console::log_1(&format!("Applied! Backup: {}", result.backup_path).into());
                            }
                            Err(e) => {
                                web_sys::console::error_1(&e.into());
                            }
                        }
                    } else {
                        web_sys::console::error_1(&"No session ID available".into());
                    }
                });
                set_show_apply_dialog.set(false);
            })
            on_cancel=Callback::new(move |_| set_show_apply_dialog.set(false))
        />
    }
})}
```
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
DefectReportDisplay has Apply Changes button when profile_path provided.
PrintAnalysisPage extracts session_id from response and uses it for apply flow.
ChangePreview dialog appears and invokes apply_recommendations with correct session_id.
  </done>
</task>

</tasks>

<verification>
1. `trunk build` - compiles without errors
2. ChangePreview dialog renders with checkbox selection
3. Apply button visible only when profile_path provided
4. session_id extracted from AnalyzeResponse and used in apply flow
5. Commands wrapper functions exist in src/commands.rs
</verification>

<success_criteria>
- User can click "Apply Changes to Profile" after analysis
- ChangePreview dialog shows selectable recommendations with before/after
- session_id is correctly extracted from analysis response
- Apply invokes backend with correct session_id
- Apply creates backup in .backups/ directory
- Apply modifies profile with selected changes
</success_criteria>

<output>
After completion, create `.planning/phases/07-auto-tuning-refinement/07-03-SUMMARY.md`
</output>
