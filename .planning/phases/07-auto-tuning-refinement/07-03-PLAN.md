---
phase: 07-auto-tuning-refinement
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/components/defect_report.rs
  - src/components/change_preview.rs
  - src/components/history_panel.rs
  - src/components/mod.rs
  - src/pages/print_analysis.rs
  - src/commands.rs
  - styles/change_preview.css
  - styles/history_panel.css
autonomous: false

must_haves:
  truths:
    - "User can click Apply Changes to modify their profile"
    - "User can select/deselect individual recommendations before applying"
    - "User sees confirmation dialog with before/after comparison"
    - "User can view history of past analysis sessions"
    - "User can revert to a previous profile state"
  artifacts:
    - path: "src/components/change_preview.rs"
      provides: "ChangePreview dialog component"
      min_lines: 80
    - path: "src/components/history_panel.rs"
      provides: "HistoryPanel component for refinement history"
      min_lines: 60
    - path: "src/components/defect_report.rs"
      provides: "Apply Changes button in recommendations section"
      contains: "Apply Changes"
    - path: "src/pages/print_analysis.rs"
      provides: "Apply flow and history integration"
      contains: "ChangePreview"
  key_links:
    - from: "src/components/change_preview.rs"
      to: "src/commands.rs::apply_recommendations"
      via: "invoke on confirm"
      pattern: "apply_recommendations"
    - from: "src/components/history_panel.rs"
      to: "src/commands.rs::list_history_sessions"
      via: "Resource fetch"
      pattern: "list_history_sessions"
    - from: "src/pages/print_analysis.rs"
      to: "src/components/change_preview.rs"
      via: "modal dialog"
      pattern: "ChangePreview"
---

<objective>
Build the frontend UI for applying recommendations and viewing refinement history. Users can select which changes to apply, see before/after comparisons, and browse their refinement history with revert capability.

Purpose: This completes the auto-tuning loop. After analysis, users can one-click apply changes. They can also view past sessions and revert if a change made things worse.

Output: ChangePreview dialog, HistoryPanel component, Apply button in DefectReportDisplay, integrated into print_analysis page.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-auto-tuning-refinement/07-RESEARCH.md
@.planning/phases/07-auto-tuning-refinement/07-02-PLAN.md
@src/components/defect_report.rs
@src/pages/print_analysis.rs
@src/commands.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChangePreview dialog component</name>
  <files>
    src/components/change_preview.rs
    src/components/mod.rs
    styles/change_preview.css
  </files>
  <action>
Create a modal dialog for previewing and confirming changes before apply:

**change_preview.rs:**
```rust
//! Change preview dialog for applying recommendations.

use leptos::prelude::*;
use crate::pages::print_analysis::RecommendationDisplay;

/// Dialog for previewing and confirming parameter changes.
#[component]
pub fn ChangePreview(
    recommendations: Vec<RecommendationDisplay>,
    profile_path: String,
    on_apply: Callback<Vec<String>>,  // selected params
    on_cancel: Callback<()>,
) -> impl IntoView {
    // Track which recommendations are selected (all by default)
    let (selected, set_selected) = signal(
        recommendations.iter().map(|r| r.parameter.clone()).collect::<Vec<_>>()
    );

    let toggle_param = move |param: String| {
        set_selected.update(|s| {
            if s.contains(&param) {
                s.retain(|p| p != &param);
            } else {
                s.push(param);
            }
        });
    };

    let confirm_apply = move |_| {
        on_apply.call(selected.get());
    };

    view! {
        <div class="change-preview-overlay">
            <style>{include_str!("change_preview.css")}</style>
            <div class="change-preview-dialog">
                <h3>"Apply Recommended Changes"</h3>
                <p class="dialog-subtitle">
                    "Select which changes to apply. A backup will be created automatically."
                </p>
                <p class="dialog-profile">
                    "Profile: " <code>{profile_path.clone()}</code>
                </p>

                <div class="changes-list">
                    {recommendations.iter().map(|rec| {
                        let param = rec.parameter.clone();
                        let param_for_toggle = param.clone();
                        let param_for_check = param.clone();
                        let label = rec.parameter_label.clone();
                        let change = rec.change_display.clone();
                        let rationale = rec.rationale.clone();

                        view! {
                            <div class="change-item">
                                <label class="change-checkbox">
                                    <input
                                        type="checkbox"
                                        checked=move || selected.get().contains(&param_for_check)
                                        on:change=move |_| toggle_param(param_for_toggle.clone())
                                    />
                                    <div class="change-details">
                                        <span class="param-label">{label}</span>
                                        <span class="change-arrow">{change}</span>
                                    </div>
                                </label>
                                <p class="change-rationale">{rationale}</p>
                            </div>
                        }
                    }).collect::<Vec<_>>()}
                </div>

                <div class="dialog-actions">
                    <button class="btn btn-secondary" on:click=move |_| on_cancel.call(())>
                        "Cancel"
                    </button>
                    <button
                        class="btn btn-primary"
                        on:click=confirm_apply
                        disabled=move || selected.get().is_empty()
                    >
                        {move || format!("Apply {} Changes", selected.get().len())}
                    </button>
                </div>
            </div>
        </div>
    }
}
```

**change_preview.css:** Modal overlay, dialog box, checkbox styling, change-item layout with before/after values, action buttons at bottom. Use existing BambuMate dark theme colors.

Update components/mod.rs to export: `pub mod change_preview;`
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
ChangePreview component renders as overlay dialog with selectable changes and Apply/Cancel buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Apply button and history to DefectReportDisplay</name>
  <files>
    src/components/defect_report.rs
    src/pages/print_analysis.rs
    src/commands.rs
  </files>
  <action>
**Update DefectReportDisplay** to accept callbacks and show Apply button:

Change the component signature to accept optional callbacks:
```rust
#[component]
pub fn DefectReportDisplay(
    defect_report: DefectReport,
    recommendations: Vec<RecommendationDisplay>,
    conflicts: Vec<Conflict>,
    material_type: String,
    #[prop(optional)] profile_path: Option<String>,
    #[prop(optional)] on_apply_click: Option<Callback<()>>,
) -> impl IntoView
```

In the recommendations section, after the recommendations-list div, add:
```rust
// Apply button (only if profile_path provided and recommendations exist)
{(!recommendations.is_empty() && profile_path.is_some()).then(|| {
    let on_click = on_apply_click.clone();
    view! {
        <div class="apply-section">
            <button
                class="btn btn-primary apply-btn"
                on:click=move |_| {
                    if let Some(cb) = &on_click {
                        cb.call(());
                    }
                }
            >
                "Apply Changes to Profile"
            </button>
            <p class="apply-hint">"A backup will be created before any changes are made."</p>
        </div>
    }
})}
```

**Add commands to src/commands.rs:**
```rust
/// Apply recommended changes to a profile.
pub async fn apply_recommendations(
    profile_path: String,
    session_id: i64,
    selected_parameters: Vec<String>,
) -> Result<ApplyResult, String> {
    #[derive(Serialize)]
    struct Args {
        request: ApplyRequest,
    }
    #[derive(Serialize)]
    struct ApplyRequest {
        profile_path: String,
        session_id: i64,
        selected_parameters: Vec<String>,
    }

    invoke::<_, ApplyResult>("apply_recommendations", Args {
        request: ApplyRequest {
            profile_path,
            session_id,
            selected_parameters,
        }
    }).await
}

/// List refinement sessions for a profile.
pub async fn list_history_sessions(profile_path: String) -> Result<Vec<SessionSummary>, String> {
    #[derive(Serialize)]
    struct Args { profile_path: String }
    invoke("list_history_sessions", Args { profile_path }).await
}

/// Get details of a specific session.
pub async fn get_history_session(session_id: i64) -> Result<SessionDetail, String> {
    #[derive(Serialize)]
    struct Args { session_id: i64 }
    invoke("get_history_session", Args { session_id }).await
}

/// Revert profile to a backup.
pub async fn revert_to_backup(session_id: i64) -> Result<String, String> {
    #[derive(Serialize)]
    struct Args { session_id: i64 }
    invoke("revert_to_backup", Args { session_id }).await
}
```

Add necessary types at top of commands.rs:
```rust
#[derive(Debug, Clone, Deserialize)]
pub struct ApplyResult {
    pub backup_path: String,
    pub changes_applied: Vec<AppliedChange>,
    pub profile_path: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct AppliedChange {
    pub parameter: String,
    pub old_value: f32,
    pub new_value: f32,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SessionSummary {
    pub id: i64,
    pub created_at: String,
    pub was_applied: bool,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SessionDetail {
    pub id: i64,
    pub profile_path: String,
    pub created_at: String,
    pub analysis_json: String,
    pub applied_changes: Option<Vec<AppliedChange>>,
    pub backup_path: Option<String>,
}
```

**Update print_analysis.rs** AnalysisState and page logic to support the apply flow - this is done in Task 3.
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
DefectReportDisplay has Apply Changes button when profile_path provided.
Frontend commands wrap all 4 new Tauri commands.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate apply flow into PrintAnalysisPage</name>
  <files>
    src/pages/print_analysis.rs
    src/components/history_panel.rs
    src/components/mod.rs
    styles/history_panel.css
  </files>
  <action>
**Create HistoryPanel component (history_panel.rs):**
```rust
//! History panel showing refinement sessions.

use leptos::prelude::*;
use wasm_bindgen_futures::spawn_local;
use crate::commands::{self, SessionSummary};

#[component]
pub fn HistoryPanel(
    profile_path: String,
    on_revert: Callback<i64>,  // session_id
) -> impl IntoView {
    let (sessions, set_sessions) = signal::<Option<Vec<SessionSummary>>>(None);
    let (loading, set_loading) = signal(true);
    let (error, set_error) = signal::<Option<String>>(None);

    // Load sessions on mount
    {
        let path = profile_path.clone();
        spawn_local(async move {
            match commands::list_history_sessions(path).await {
                Ok(s) => set_sessions.set(Some(s)),
                Err(e) => set_error.set(Some(e)),
            }
            set_loading.set(false);
        });
    }

    view! {
        <div class="history-panel">
            <style>{include_str!("history_panel.css")}</style>
            <h4>"Refinement History"</h4>

            {move || {
                if loading.get() {
                    view! { <p class="loading">"Loading history..."</p> }.into_any()
                } else if let Some(err) = error.get() {
                    view! { <p class="error">{err}</p> }.into_any()
                } else if let Some(sessions) = sessions.get() {
                    if sessions.is_empty() {
                        view! { <p class="no-history">"No history for this profile yet."</p> }.into_any()
                    } else {
                        view! {
                            <div class="history-list">
                                {sessions.iter().map(|s| {
                                    let id = s.id;
                                    let date = s.created_at.clone();
                                    let applied = s.was_applied;
                                    view! {
                                        <div class="history-item">
                                            <span class="history-date">{date}</span>
                                            <span class="history-status">
                                                {if applied { "[Applied]" } else { "[Analyzed]" }}
                                            </span>
                                            {applied.then(|| view! {
                                                <button
                                                    class="btn btn-small btn-secondary"
                                                    on:click=move |_| on_revert.call(id)
                                                >
                                                    "Revert"
                                                </button>
                                            })}
                                        </div>
                                    }
                                }).collect::<Vec<_>>()}
                            </div>
                        }.into_any()
                    }
                } else {
                    view! { <p>"No data"</p> }.into_any()
                }
            }}
        </div>
    }
}
```

Update components/mod.rs: `pub mod history_panel;`

**Update print_analysis.rs** to integrate apply flow:

1. Add profile_path state for when user provides one:
```rust
let (profile_path, set_profile_path) = signal::<Option<String>>(None);
let (show_apply_dialog, set_show_apply_dialog) = signal(false);
let (current_session_id, set_current_session_id) = signal::<Option<i64>>(None);
```

2. Add a profile path input in the Ready state (optional - user can browse for a profile):
```rust
<div class="profile-selector">
    <label>"Profile to update (optional):"</label>
    <input
        type="text"
        class="input"
        placeholder="/path/to/profile.json"
        on:input=move |ev| {
            let val = event_target_value(&ev);
            if val.is_empty() {
                set_profile_path.set(None);
            } else {
                set_profile_path.set(Some(val));
            }
        }
    />
</div>
```

3. In AnalysisState::Complete, pass on_apply_click callback to DefectReportDisplay:
```rust
let on_apply = move || {
    set_show_apply_dialog.set(true);
};

<DefectReportDisplay
    defect_report=response.defect_report.clone()
    recommendations=response.recommendations.clone()
    conflicts=response.conflicts.clone()
    material_type=response.material_type.clone()
    profile_path=profile_path.get()
    on_apply_click=Some(Callback::new(move |_| on_apply()))
/>
```

4. Show ChangePreview dialog when show_apply_dialog is true:
```rust
{move || show_apply_dialog.get().then(|| {
    let recs = /* get recommendations from current state */;
    let path = profile_path.get().unwrap_or_default();
    view! {
        <ChangePreview
            recommendations=recs
            profile_path=path.clone()
            on_apply=Callback::new(move |selected: Vec<String>| {
                // Call apply_recommendations
                let session = current_session_id.get();
                let p = path.clone();
                spawn_local(async move {
                    if let Some(sid) = session {
                        match commands::apply_recommendations(p, sid, selected).await {
                            Ok(result) => {
                                // Show success, close dialog
                                web_sys::console::log_1(&format!("Applied! Backup: {}", result.backup_path).into());
                            }
                            Err(e) => {
                                web_sys::console::error_1(&e.into());
                            }
                        }
                    }
                });
                set_show_apply_dialog.set(false);
            })
            on_cancel=Callback::new(move |_| set_show_apply_dialog.set(false))
        />
    }
})}
```

Create styles/history_panel.css with appropriate styling for list, items, dates, status badges, and revert buttons.
  </action>
  <verify>
`trunk build` compiles without errors.
  </verify>
  <done>
PrintAnalysisPage shows ChangePreview dialog on Apply click.
HistoryPanel component displays sessions with Revert buttons.
Apply flow creates backup and records changes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Auto-apply flow with backup creation, change preview dialog, and refinement history panel.
  </what-built>
  <how-to-verify>
1. Run `cargo tauri dev` to launch the app
2. Navigate to Print Analysis page
3. Upload a test print photo
4. Optionally enter a profile path (e.g., an existing Bambu Studio profile)
5. Click "Analyze Print"
6. After analysis completes, click "Apply Changes to Profile"
7. Verify the ChangePreview dialog appears with selectable changes
8. Toggle some checkboxes to verify selection works
9. Click "Apply" and verify:
   - A .backups/ folder is created in the profile's directory
   - A timestamped backup file exists
   - The profile JSON is modified with new values
10. If History panel is visible, verify it shows the session
11. Test Revert if a session with backup exists

Expected: User can apply changes with confirmation, backup is created, history tracks the session.
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `trunk build` - compiles without errors
2. ChangePreview dialog renders with checkbox selection
3. Apply button visible only when profile_path provided
4. Commands wrapper functions exist in src/commands.rs
5. HistoryPanel shows sessions and Revert buttons
</verification>

<success_criteria>
- User can click "Apply Changes to Profile" after analysis
- ChangePreview dialog shows selectable recommendations with before/after
- Apply creates backup in .backups/ directory
- Apply modifies profile with selected changes
- History panel shows past sessions
- Revert button restores profile from backup
</success_criteria>

<output>
After completion, create `.planning/phases/07-auto-tuning-refinement/07-03-SUMMARY.md`
</output>
