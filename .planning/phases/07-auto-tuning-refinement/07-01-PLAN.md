---
phase: 07-auto-tuning-refinement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/history/mod.rs
  - src-tauri/src/history/types.rs
  - src-tauri/src/history/store.rs
  - src-tauri/src/profile/writer.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Profile backups are created before any modification"
    - "Analysis sessions are recorded in persistent storage"
    - "Applied changes are tracked with before/after values"
  artifacts:
    - path: "src-tauri/src/history/mod.rs"
      provides: "History module exports"
    - path: "src-tauri/src/history/types.rs"
      provides: "AppliedChange, SessionSummary, SessionDetail types"
      exports: ["AppliedChange", "SessionSummary", "SessionDetail"]
    - path: "src-tauri/src/history/store.rs"
      provides: "RefinementHistory SQLite store"
      exports: ["RefinementHistory"]
    - path: "src-tauri/src/profile/writer.rs"
      provides: "backup_profile function"
      contains: "pub fn backup_profile"
  key_links:
    - from: "src-tauri/src/history/store.rs"
      to: "rusqlite"
      via: "Connection::open"
      pattern: "Connection::open"
    - from: "src-tauri/src/profile/writer.rs"
      to: "std::fs"
      via: "fs::copy for backup"
      pattern: "fs::copy"
---

<objective>
Create the backend foundation for refinement history: SQLite persistence for analysis sessions, backup_profile() function for pre-modification snapshots, and types for tracking applied changes.

Purpose: This foundation enables the auto-apply workflow. Before any profile modification, a backup is created. Every analysis session is recorded so users can see their refinement history and revert changes.

Output: history/ module with SQLite store, backup_profile() in writer.rs, ready for Plan 02 to wire commands.
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-auto-tuning-refinement/07-RESEARCH.md
@src-tauri/src/profile/writer.rs
@src-tauri/src/scraper/cache.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create history types and SQLite store</name>
  <files>
    src-tauri/src/history/mod.rs
    src-tauri/src/history/types.rs
    src-tauri/src/history/store.rs
  </files>
  <action>
Create the history module following the existing scraper/cache.rs SQLite pattern:

**types.rs:**
```rust
use serde::{Deserialize, Serialize};

/// A recorded change to a profile parameter.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppliedChange {
    pub parameter: String,
    pub old_value: f32,
    pub new_value: f32,
}

/// Summary of a refinement session for list views.
#[derive(Debug, Clone, Serialize)]
pub struct SessionSummary {
    pub id: i64,
    pub created_at: String,
    pub was_applied: bool,
}

/// Full details of a refinement session.
#[derive(Debug, Clone, Serialize)]
pub struct SessionDetail {
    pub id: i64,
    pub profile_path: String,
    pub created_at: String,
    pub analysis_json: String,
    pub applied_changes: Option<Vec<AppliedChange>>,
    pub backup_path: Option<String>,
}
```

**store.rs:**
- RefinementHistory struct with rusqlite Connection
- new(db_path) - creates refinement_sessions table with columns: id, profile_path, created_at, image_base64 (nullable), analysis_json, applied_changes_json (nullable), backup_path (nullable)
- Indexes on profile_path and created_at DESC
- record_analysis(profile_path, image_base64, analysis_json) -> session_id
- record_apply(session_id, changes, backup_path) - updates existing session
- list_sessions(profile_path) -> Vec<SessionSummary>
- get_session(session_id) -> SessionDetail

Use the same error handling pattern as scraper/cache.rs (map_err to String).
Database location: get from Tauri data dir, file: refinement_history.db

**mod.rs:**
```rust
mod types;
mod store;

pub use types::*;
pub use store::RefinementHistory;
```
  </action>
  <verify>
`cargo check -p bambumate` passes with no errors.
`cargo test -p bambumate -- history` passes (add basic tests for store operations).
  </verify>
  <done>
history module exists with types (AppliedChange, SessionSummary, SessionDetail) and RefinementHistory store implementing record_analysis, record_apply, list_sessions, get_session.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add backup_profile function to writer</name>
  <files>src-tauri/src/profile/writer.rs</files>
  <action>
Add a backup_profile() function to the existing writer.rs:

```rust
use chrono::Utc;

/// Create a timestamped backup of a profile before modification.
/// Returns the backup path on success.
pub fn backup_profile(profile_path: &Path) -> Result<PathBuf> {
    let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
    let stem = profile_path.file_stem()
        .and_then(|s| s.to_str())
        .ok_or_else(|| anyhow::anyhow!("Invalid profile path"))?;

    // Create .backups directory alongside profile
    let backup_dir = profile_path.parent()
        .ok_or_else(|| anyhow::anyhow!("No parent directory"))?
        .join(".backups");
    std::fs::create_dir_all(&backup_dir)?;

    let backup_name = format!("{}_{}.json", stem, timestamp);
    let backup_path = backup_dir.join(backup_name);

    std::fs::copy(profile_path, &backup_path)?;

    info!("Created backup at {:?}", backup_path);
    Ok(backup_path)
}
```

Add chrono to Cargo.toml if not present (check first - likely already there from scraper).

Also add a restore_from_backup function:
```rust
/// Restore a profile from a backup file.
pub fn restore_from_backup(backup_path: &Path, profile_path: &Path) -> Result<()> {
    let backup_profile = super::reader::read_profile(backup_path)?;
    write_profile_atomic(&backup_profile, profile_path)?;
    info!("Restored profile from {:?}", backup_path);
    Ok(())
}
```
  </action>
  <verify>
`cargo check -p bambumate` passes.
`cargo test -p bambumate -- profile::writer` includes a test for backup_profile.
  </verify>
  <done>
backup_profile() creates timestamped backups in .backups/ subdirectory.
restore_from_backup() can restore a profile from backup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire history module to lib.rs</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Add the history module declaration to lib.rs:

```rust
pub mod history;
```

Add re-exports if following existing pattern:
```rust
pub use history::{AppliedChange, RefinementHistory, SessionDetail, SessionSummary};
```

Verify it builds cleanly with all existing modules.
  </action>
  <verify>
`cargo check -p bambumate` passes with history module integrated.
`cargo build -p bambumate` completes successfully.
  </verify>
  <done>
history module is part of the crate, types and store accessible from other modules.
  </done>
</task>

</tasks>

<verification>
1. `cargo check -p bambumate` - no errors
2. `cargo test -p bambumate` - all existing tests pass, new history tests pass
3. history module exports: AppliedChange, SessionSummary, SessionDetail, RefinementHistory
4. writer.rs exports: backup_profile, restore_from_backup
</verification>

<success_criteria>
- RefinementHistory can create, query, and update refinement sessions
- backup_profile() creates timestamped copy in .backups/ directory
- All existing 85+ tests continue to pass
- New history tests verify CRUD operations
</success_criteria>

<output>
After completion, create `.planning/phases/07-auto-tuning-refinement/07-01-SUMMARY.md`
</output>
