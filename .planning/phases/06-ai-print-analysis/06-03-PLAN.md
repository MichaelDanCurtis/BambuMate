---
phase: 06-ai-print-analysis
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - Cargo.toml
  - src/app.rs
  - src/commands.rs
  - src/pages/mod.rs
  - src/pages/print_analysis.rs
  - src/components/mod.rs
  - src/components/defect_report.rs
  - src/components/sidebar.rs
  - styles/main.css
autonomous: false

must_haves:
  truths:
    - "User can drag-and-drop a photo onto the analysis page"
    - "User can browse for a photo via file picker"
    - "Analysis results display defects with severity and confidence"
    - "Recommendations show parameter changes as 'current -> suggested'"
    - "User can see conflicts between recommendations when they exist"
  artifacts:
    - path: "src/pages/print_analysis.rs"
      provides: "Print analysis page with photo upload"
      contains: "PrintAnalysisPage"
    - path: "src/components/defect_report.rs"
      provides: "Defect display and recommendations"
      contains: "DefectReport"
    - path: "Cargo.toml"
      provides: "leptos-use dependency for drop zone"
      contains: "leptos-use"
  key_links:
    - from: "src/pages/print_analysis.rs"
      to: "src/commands.rs"
      via: "invoke analyze_print"
      pattern: "invoke.*analyze_print"
    - from: "src/app.rs"
      to: "src/pages/print_analysis.rs"
      via: "Route for /analysis"
      pattern: "Route.*analysis.*PrintAnalysisPage"
---

<objective>
Create the frontend UI for print photo analysis with drag-and-drop upload, results display, and recommendation visualization.

Purpose: This completes the user-facing experience for Phase 6 - users can now photograph a test print, drop it into BambuMate, and receive AI-powered defect analysis with actionable recommendations.

Output:
- `src/pages/print_analysis.rs` - Analysis page with photo upload
- `src/components/defect_report.rs` - Results display component
- Route registered in app.rs, sidebar nav updated
</objective>

<execution_context>
@/Users/michaelcurtis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/michaelcurtis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-print-analysis/06-RESEARCH.md

# Prior plan summaries
@.planning/phases/06-ai-print-analysis/06-01-SUMMARY.md
@.planning/phases/06-ai-print-analysis/06-02-SUMMARY.md

# Frontend patterns
@src/app.rs
@src/commands.rs
@src/pages/filament_search.rs
@src/components/sidebar.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add leptos-use dependency and create analysis page structure</name>
  <files>
    Cargo.toml
    src/pages/mod.rs
    src/pages/print_analysis.rs
    src/commands.rs
  </files>
  <action>
1. Add leptos-use to Cargo.toml (frontend workspace):

```toml
leptos-use = { version = "0.15", features = ["use_drop_zone"] }
```

2. Add to src/pages/mod.rs:
```rust
pub mod print_analysis;
```

3. Create src/pages/print_analysis.rs:

```rust
//! Print analysis page for AI-powered defect detection.
//!
//! Users can drag-and-drop or browse for a print photo to analyze.

use leptos::prelude::*;
use leptos::html::Div;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use wasm_bindgen_futures::spawn_local;

use crate::commands;
use crate::components::defect_report::DefectReportDisplay;

/// Request payload for print analysis.
#[derive(Debug, Clone, Serialize)]
pub struct AnalyzeRequest {
    pub image_base64: String,
    pub profile_path: Option<String>,
    pub material_type: Option<String>,
}

/// Detected defect from AI analysis.
#[derive(Debug, Clone, Deserialize)]
pub struct DetectedDefect {
    pub defect_type: String,
    pub severity: f32,
    pub confidence: f32,
}

/// Defect report from vision API.
#[derive(Debug, Clone, Deserialize)]
pub struct DefectReport {
    pub defects: Vec<DetectedDefect>,
    pub overall_quality: String,
    pub notes: Option<String>,
}

/// Conflict between recommendations.
#[derive(Debug, Clone, Deserialize)]
pub struct Conflict {
    pub parameter: String,
    pub conflicting_defects: Vec<String>,
    pub description: String,
}

/// Parameter recommendation with display info.
#[derive(Debug, Clone, Deserialize)]
pub struct RecommendationDisplay {
    pub defect: String,
    pub parameter: String,
    pub parameter_label: String,
    pub current_value: f32,
    pub recommended_value: f32,
    pub change_display: String,
    pub unit: String,
    pub priority: u8,
    pub rationale: String,
    pub was_clamped: bool,
}

/// Full analysis response.
#[derive(Debug, Clone, Deserialize)]
pub struct AnalyzeResponse {
    pub defect_report: DefectReport,
    pub recommendations: Vec<RecommendationDisplay>,
    pub conflicts: Vec<Conflict>,
    pub current_values: HashMap<String, f32>,
    pub material_type: String,
}

/// Analysis state enum.
#[derive(Debug, Clone, PartialEq)]
pub enum AnalysisState {
    /// Waiting for image upload
    Idle,
    /// Image loaded, ready to analyze
    Ready(String), // base64 image
    /// Analysis in progress
    Analyzing,
    /// Analysis complete with results
    Complete(AnalyzeResponse),
    /// Error occurred
    Error(String),
}

/// Print analysis page component.
#[component]
pub fn PrintAnalysisPage() -> impl IntoView {
    let (state, set_state) = signal(AnalysisState::Idle);
    let (image_preview, set_image_preview) = signal::<Option<String>>(None);
    let (material_override, set_material_override) = signal::<Option<String>>(None);

    // Handle file selection (from drop or browse)
    let on_file_selected = move |base64: String| {
        set_image_preview.set(Some(format!("data:image/jpeg;base64,{}", base64.clone())));
        set_state.set(AnalysisState::Ready(base64));
    };

    // Handle analyze button click
    let on_analyze = move |_| {
        let current_state = state.get();
        if let AnalysisState::Ready(base64) = current_state {
            set_state.set(AnalysisState::Analyzing);

            let material = material_override.get();
            spawn_local(async move {
                match commands::analyze_print(base64, None, material).await {
                    Ok(response) => {
                        set_state.set(AnalysisState::Complete(response));
                    }
                    Err(e) => {
                        set_state.set(AnalysisState::Error(e));
                    }
                }
            });
        }
    };

    // Reset to try another image
    let on_reset = move |_| {
        set_state.set(AnalysisState::Idle);
        set_image_preview.set(None);
    };

    view! {
        <div class="page-container">
            <h1 class="page-title">"Print Analysis"</h1>
            <p class="page-description">
                "Upload a photo of your test print to detect defects and get recommendations."
            </p>

            {move || match state.get() {
                AnalysisState::Idle => view! {
                    <PhotoDropZone on_file=on_file_selected.clone() />
                }.into_any(),

                AnalysisState::Ready(_) => view! {
                    <div class="analysis-preview">
                        {move || image_preview.get().map(|src| view! {
                            <img src=src class="preview-image" alt="Print to analyze" />
                        })}

                        <div class="material-selector">
                            <label>"Material type (optional):"</label>
                            <select on:change=move |ev| {
                                let value = event_target_value(&ev);
                                if value.is_empty() {
                                    set_material_override.set(None);
                                } else {
                                    set_material_override.set(Some(value));
                                }
                            }>
                                <option value="">"Auto-detect"</option>
                                <option value="PLA">"PLA"</option>
                                <option value="PETG">"PETG"</option>
                                <option value="ABS">"ABS"</option>
                                <option value="ASA">"ASA"</option>
                                <option value="TPU">"TPU"</option>
                                <option value="PA">"Nylon (PA)"</option>
                                <option value="PC">"Polycarbonate (PC)"</option>
                            </select>
                        </div>

                        <div class="action-buttons">
                            <button class="btn btn-primary" on:click=on_analyze>
                                "Analyze Print"
                            </button>
                            <button class="btn btn-secondary" on:click=on_reset>
                                "Choose Different Photo"
                            </button>
                        </div>
                    </div>
                }.into_any(),

                AnalysisState::Analyzing => view! {
                    <div class="analyzing-state">
                        {move || image_preview.get().map(|src| view! {
                            <img src=src class="preview-image analyzing" alt="Analyzing..." />
                        })}
                        <div class="loading-indicator">
                            <div class="spinner"></div>
                            <p>"Analyzing your print..."</p>
                            <p class="hint">"This may take 10-30 seconds"</p>
                        </div>
                    </div>
                }.into_any(),

                AnalysisState::Complete(response) => view! {
                    <div class="analysis-results">
                        {move || image_preview.get().map(|src| view! {
                            <img src=src class="preview-image small" alt="Analyzed print" />
                        })}

                        <DefectReportDisplay
                            defect_report=response.defect_report.clone()
                            recommendations=response.recommendations.clone()
                            conflicts=response.conflicts.clone()
                            material_type=response.material_type.clone()
                        />

                        <div class="action-buttons">
                            <button class="btn btn-secondary" on:click=on_reset>
                                "Analyze Another Photo"
                            </button>
                        </div>
                    </div>
                }.into_any(),

                AnalysisState::Error(msg) => view! {
                    <div class="error-state">
                        <div class="error-message">
                            <h3>"Analysis Failed"</h3>
                            <p>{msg}</p>
                        </div>
                        <button class="btn btn-secondary" on:click=on_reset>
                            "Try Again"
                        </button>
                    </div>
                }.into_any(),
            }}
        </div>
    }
}

/// Photo drop zone component with drag-and-drop and browse.
#[component]
fn PhotoDropZone<F>(on_file: F) -> impl IntoView
where
    F: Fn(String) + Clone + 'static,
{
    let drop_zone_el = NodeRef::<Div>::new();
    let (is_over, set_is_over) = signal(false);
    let (is_loading, set_is_loading) = signal(false);
    let file_input_id = "photo-file-input";

    // Handle file reading
    let process_file = {
        let on_file = on_file.clone();
        move |file: web_sys::File| {
            let on_file = on_file.clone();
            set_is_loading.set(true);

            spawn_local(async move {
                match read_file_as_base64(file).await {
                    Ok(base64) => {
                        on_file(base64);
                    }
                    Err(e) => {
                        web_sys::console::error_1(&format!("Failed to read file: {}", e).into());
                    }
                }
                set_is_loading.set(false);
            });
        }
    };

    // Handle drop event
    let on_drop = {
        let process_file = process_file.clone();
        move |ev: web_sys::DragEvent| {
            ev.prevent_default();
            set_is_over.set(false);

            if let Some(dt) = ev.data_transfer() {
                if let Some(files) = dt.files() {
                    if let Some(file) = files.get(0) {
                        process_file(file);
                    }
                }
            }
        }
    };

    // Handle file input change
    let on_input_change = {
        let process_file = process_file.clone();
        move |ev: web_sys::Event| {
            let input: web_sys::HtmlInputElement = event_target(&ev);
            if let Some(files) = input.files() {
                if let Some(file) = files.get(0) {
                    process_file(file);
                }
            }
        }
    };

    view! {
        <div
            node_ref=drop_zone_el
            class="drop-zone"
            class:drop-zone-active=move || is_over.get()
            class:drop-zone-loading=move || is_loading.get()
            on:dragover=move |ev| {
                ev.prevent_default();
                set_is_over.set(true);
            }
            on:dragleave=move |_| set_is_over.set(false)
            on:drop=on_drop
        >
            {move || if is_loading.get() {
                view! {
                    <div class="drop-zone-loading">
                        <div class="spinner"></div>
                        <p>"Loading image..."</p>
                    </div>
                }.into_any()
            } else {
                view! {
                    <div class="drop-zone-content">
                        <div class="drop-icon">"ðŸ“·"</div>
                        <p class="drop-main">"Drop a photo of your print here"</p>
                        <p class="drop-hint">"or"</p>
                        <label for=file_input_id class="btn btn-secondary">
                            "Browse Files"
                        </label>
                        <input
                            type="file"
                            id=file_input_id
                            accept="image/*"
                            style="display: none"
                            on:change=on_input_change
                        />
                        <p class="drop-formats">"Supports JPEG, PNG, WebP"</p>
                    </div>
                }.into_any()
            }}
        </div>
    }
}

/// Read a File as base64 string.
async fn read_file_as_base64(file: web_sys::File) -> Result<String, String> {
    use js_sys::{ArrayBuffer, Uint8Array};
    use wasm_bindgen::JsCast;
    use wasm_bindgen_futures::JsFuture;

    let array_buffer: ArrayBuffer = JsFuture::from(file.array_buffer())
        .await
        .map_err(|e| format!("Failed to read file: {:?}", e))?
        .dyn_into()
        .map_err(|_| "Failed to convert to ArrayBuffer")?;

    let uint8_array = Uint8Array::new(&array_buffer);
    let bytes = uint8_array.to_vec();

    // Base64 encode
    Ok(base64_encode(&bytes))
}

/// Simple base64 encoder (avoiding extra dependencies in WASM).
fn base64_encode(bytes: &[u8]) -> String {
    const ALPHABET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    let mut result = String::with_capacity((bytes.len() + 2) / 3 * 4);

    for chunk in bytes.chunks(3) {
        let b0 = chunk[0] as usize;
        let b1 = chunk.get(1).copied().unwrap_or(0) as usize;
        let b2 = chunk.get(2).copied().unwrap_or(0) as usize;

        result.push(ALPHABET[b0 >> 2] as char);
        result.push(ALPHABET[((b0 & 0x03) << 4) | (b1 >> 4)] as char);

        if chunk.len() > 1 {
            result.push(ALPHABET[((b1 & 0x0f) << 2) | (b2 >> 6)] as char);
        } else {
            result.push('=');
        }

        if chunk.len() > 2 {
            result.push(ALPHABET[b2 & 0x3f] as char);
        } else {
            result.push('=');
        }
    }

    result
}

/// Helper to get event target value
fn event_target_value(ev: &web_sys::Event) -> String {
    use wasm_bindgen::JsCast;
    ev.target()
        .and_then(|t| t.dyn_into::<web_sys::HtmlSelectElement>().ok())
        .map(|el| el.value())
        .unwrap_or_default()
}

/// Helper to get event target
fn event_target<T: wasm_bindgen::JsCast>(ev: &web_sys::Event) -> T {
    ev.target().unwrap().dyn_into::<T>().unwrap()
}
```

4. Add the analyze_print command wrapper to src/commands.rs:

```rust
/// Analyze a print photo for defects.
pub async fn analyze_print(
    image_base64: String,
    profile_path: Option<String>,
    material_type: Option<String>,
) -> Result<crate::pages::print_analysis::AnalyzeResponse, String> {
    #[derive(serde::Serialize)]
    struct Request {
        image_base64: String,
        profile_path: Option<String>,
        material_type: Option<String>,
    }

    let request = Request {
        image_base64,
        profile_path,
        material_type,
    };

    invoke("analyze_print", serde_wasm_bindgen::to_value(&request).unwrap())
        .await
        .map_err(|e| format!("{:?}", e))
        .and_then(|v| {
            serde_wasm_bindgen::from_value(v)
                .map_err(|e| format!("Failed to parse response: {}", e))
        })
}
```
  </action>
  <verify>
    `cd /Users/michaelcurtis/Development/BambuMate && cargo check`
  </verify>
  <done>
    - leptos-use added to Cargo.toml (or native drop zone if simpler)
    - print_analysis.rs page created with drop zone and state machine
    - analyze_print command wrapper added
  </done>
</task>

<task type="auto">
  <name>Task 2: Create defect report display component</name>
  <files>
    src/components/mod.rs
    src/components/defect_report.rs
  </files>
  <action>
1. Add to src/components/mod.rs:
```rust
pub mod defect_report;
```

2. Create src/components/defect_report.rs:

```rust
//! Defect report display component.
//!
//! Shows detected defects, recommendations, and conflicts in a readable format.

use leptos::prelude::*;

use crate::pages::print_analysis::{Conflict, DefectReport, RecommendationDisplay};

/// Display component for analysis results.
#[component]
pub fn DefectReportDisplay(
    defect_report: DefectReport,
    recommendations: Vec<RecommendationDisplay>,
    conflicts: Vec<Conflict>,
    material_type: String,
) -> impl IntoView {
    view! {
        <div class="defect-report">
            // Overall quality badge
            <div class="quality-section">
                <h2>"Overall Quality"</h2>
                <QualityBadge quality=defect_report.overall_quality.clone() />
                {defect_report.notes.as_ref().map(|notes| view! {
                    <p class="quality-notes">{notes}</p>
                })}
            </div>

            // Detected defects
            <div class="defects-section">
                <h2>"Detected Defects"</h2>
                {if defect_report.defects.is_empty() {
                    view! {
                        <p class="no-defects">"No defects detected - your print looks great!"</p>
                    }.into_any()
                } else {
                    view! {
                        <div class="defects-list">
                            {defect_report.defects.iter().map(|d| view! {
                                <DefectCard
                                    defect_type=d.defect_type.clone()
                                    severity=d.severity
                                    confidence=d.confidence
                                />
                            }).collect::<Vec<_>>()}
                        </div>
                    }.into_any()
                }}
            </div>

            // Recommendations
            {(!recommendations.is_empty()).then(|| view! {
                <div class="recommendations-section">
                    <h2>"Recommended Changes"</h2>
                    <p class="section-subtitle">
                        "Adjustments for " <strong>{material_type.clone()}</strong> " filament:"
                    </p>
                    <div class="recommendations-list">
                        {recommendations.iter().map(|rec| view! {
                            <RecommendationCard recommendation=rec.clone() />
                        }).collect::<Vec<_>>()}
                    </div>
                </div>
            })}

            // Conflicts warning
            {(!conflicts.is_empty()).then(|| view! {
                <div class="conflicts-section">
                    <h2>"Conflicts Detected"</h2>
                    <p class="conflicts-warning">
                        "Some defects require opposite adjustments. Review carefully:"
                    </p>
                    <div class="conflicts-list">
                        {conflicts.iter().map(|c| view! {
                            <ConflictCard conflict=c.clone() />
                        }).collect::<Vec<_>>()}
                    </div>
                </div>
            })}
        </div>
    }
}

/// Quality badge component.
#[component]
fn QualityBadge(quality: String) -> impl IntoView {
    let (badge_class, icon) = match quality.as_str() {
        "excellent" => ("quality-badge quality-excellent", "âœ“"),
        "good" => ("quality-badge quality-good", "âœ“"),
        "acceptable" => ("quality-badge quality-acceptable", "~"),
        "poor" => ("quality-badge quality-poor", "!"),
        "failed" => ("quality-badge quality-failed", "âœ—"),
        _ => ("quality-badge", "?"),
    };

    view! {
        <span class=badge_class>
            <span class="quality-icon">{icon}</span>
            <span class="quality-text">{quality.to_uppercase()}</span>
        </span>
    }
}

/// Individual defect card.
#[component]
fn DefectCard(defect_type: String, severity: f32, confidence: f32) -> impl IntoView {
    let display_name = defect_display_name(&defect_type);
    let severity_label = severity_label(severity);
    let severity_class = format!("severity-{}", severity_label.to_lowercase());

    view! {
        <div class="defect-card">
            <div class="defect-header">
                <span class="defect-name">{display_name}</span>
                <span class=format!("severity-badge {}", severity_class)>
                    {severity_label}
                </span>
            </div>
            <div class="defect-details">
                <div class="detail-row">
                    <span class="detail-label">"Severity:"</span>
                    <div class="severity-bar">
                        <div class="severity-fill" style=format!("width: {}%", severity * 100.0)></div>
                    </div>
                    <span class="detail-value">{format!("{:.0}%", severity * 100.0)}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">"Confidence:"</span>
                    <span class="detail-value">{format!("{:.0}%", confidence * 100.0)}</span>
                </div>
            </div>
        </div>
    }
}

/// Individual recommendation card.
#[component]
fn RecommendationCard(recommendation: RecommendationDisplay) -> impl IntoView {
    view! {
        <div class="recommendation-card" class:was-clamped=recommendation.was_clamped>
            <div class="rec-header">
                <span class="rec-parameter">{recommendation.parameter_label.clone()}</span>
                <span class="rec-priority">
                    {if recommendation.priority == 1 { "Primary" } else { "Secondary" }}
                </span>
            </div>
            <div class="rec-change">
                <span class="change-display">{recommendation.change_display.clone()}</span>
            </div>
            <div class="rec-rationale">
                <span class="rationale-text">{recommendation.rationale.clone()}</span>
            </div>
            <div class="rec-meta">
                <span class="meta-defect">"For: " {defect_display_name(&recommendation.defect)}</span>
                {recommendation.was_clamped.then(|| view! {
                    <span class="meta-clamped" title="Value was limited to safe operating range">
                        "âš  Clamped to safe range"
                    </span>
                })}
            </div>
        </div>
    }
}

/// Conflict card.
#[component]
fn ConflictCard(conflict: Conflict) -> impl IntoView {
    view! {
        <div class="conflict-card">
            <div class="conflict-icon">"âš "</div>
            <div class="conflict-content">
                <div class="conflict-param">{conflict.parameter.clone()}</div>
                <div class="conflict-desc">{conflict.description.clone()}</div>
                <div class="conflict-defects">
                    "Affected by: "
                    {conflict.conflicting_defects.iter().map(|d| defect_display_name(d)).collect::<Vec<_>>().join(", ")}
                </div>
            </div>
        </div>
    }
}

/// Convert defect type ID to display name.
fn defect_display_name(defect_type: &str) -> String {
    match defect_type {
        "stringing" => "Stringing/Oozing".to_string(),
        "warping" => "Warping".to_string(),
        "layer_adhesion" => "Poor Layer Adhesion".to_string(),
        "elephants_foot" => "Elephant's Foot".to_string(),
        "under_extrusion" => "Under-Extrusion".to_string(),
        "over_extrusion" => "Over-Extrusion".to_string(),
        "z_banding" => "Z-Banding".to_string(),
        _ => defect_type.replace('_', " "),
    }
}

/// Convert severity value to label.
fn severity_label(severity: f32) -> String {
    if severity < 0.3 {
        "Minor".to_string()
    } else if severity < 0.5 {
        "Noticeable".to_string()
    } else if severity < 0.7 {
        "Significant".to_string()
    } else {
        "Severe".to_string()
    }
}
```
  </action>
  <verify>
    `cd /Users/michaelcurtis/Development/BambuMate && cargo check`
  </verify>
  <done>
    - defect_report.rs component created
    - Shows quality badge, defects list, recommendations, and conflicts
    - Display-friendly formatting for all data
  </done>
</task>

<task type="auto">
  <name>Task 3: Register route and add navigation, update styles</name>
  <files>
    src/app.rs
    src/components/sidebar.rs
    styles/main.css
  </files>
  <action>
1. Update src/app.rs to add the route:

Add import:
```rust
use crate::pages::print_analysis::PrintAnalysisPage;
```

Add route in the Routes block:
```rust
<Route path=path!("/analysis") view=PrintAnalysisPage />
```

2. Update src/components/sidebar.rs to add navigation:

Find the nav items and add:
```rust
<a href="/analysis" class="nav-item" class:active=move || pathname.get() == "/analysis">
    <span class="nav-icon">"ðŸ“·"</span>
    <span class="nav-label">"Print Analysis"</span>
</a>
```

Place it after "Filament Search" in the navigation order.

3. Add styles to styles/main.css (or create if needed):

```css
/* Print Analysis Page */
.page-container {
  padding: 2rem;
  max-width: 900px;
  margin: 0 auto;
}

.page-title {
  font-size: 1.75rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.page-description {
  color: var(--text-secondary);
  margin-bottom: 2rem;
}

/* Drop Zone */
.drop-zone {
  border: 2px dashed var(--border-color);
  border-radius: 12px;
  padding: 3rem 2rem;
  text-align: center;
  transition: all 0.2s ease;
  cursor: pointer;
  background: var(--bg-secondary);
}

.drop-zone:hover,
.drop-zone-active {
  border-color: var(--accent-color);
  background: var(--bg-hover);
}

.drop-zone-loading {
  opacity: 0.7;
  pointer-events: none;
}

.drop-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.drop-main {
  font-size: 1.25rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.drop-hint {
  color: var(--text-secondary);
  margin: 0.75rem 0;
}

.drop-formats {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-top: 1rem;
}

/* Preview Image */
.preview-image {
  max-width: 100%;
  max-height: 400px;
  border-radius: 8px;
  margin-bottom: 1.5rem;
}

.preview-image.small {
  max-height: 200px;
  margin-bottom: 1rem;
}

.preview-image.analyzing {
  opacity: 0.6;
}

/* Material Selector */
.material-selector {
  margin-bottom: 1.5rem;
}

.material-selector label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.material-selector select {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-size: 1rem;
}

/* Action Buttons */
.action-buttons {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

/* Loading State */
.loading-indicator {
  text-align: center;
  padding: 2rem;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--border-color);
  border-top-color: var(--accent-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.hint {
  color: var(--text-secondary);
  font-size: 0.875rem;
}

/* Error State */
.error-state {
  text-align: center;
  padding: 2rem;
}

.error-message {
  background: var(--error-bg);
  border: 1px solid var(--error-border);
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.error-message h3 {
  color: var(--error-text);
  margin-bottom: 0.5rem;
}

/* Defect Report */
.defect-report {
  margin-top: 2rem;
}

.defect-report h2 {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-color);
}

.quality-section {
  margin-bottom: 2rem;
}

.quality-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-weight: 600;
  font-size: 1rem;
}

.quality-excellent { background: #dcfce7; color: #166534; }
.quality-good { background: #dbeafe; color: #1e40af; }
.quality-acceptable { background: #fef3c7; color: #92400e; }
.quality-poor { background: #fed7aa; color: #c2410c; }
.quality-failed { background: #fecaca; color: #b91c1c; }

.quality-notes {
  margin-top: 0.75rem;
  color: var(--text-secondary);
  font-style: italic;
}

/* Defects List */
.defects-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.defect-card {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
}

.defect-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.defect-name {
  font-weight: 600;
}

.severity-badge {
  padding: 0.25rem 0.75rem;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
}

.severity-minor { background: #dbeafe; color: #1e40af; }
.severity-noticeable { background: #fef3c7; color: #92400e; }
.severity-significant { background: #fed7aa; color: #c2410c; }
.severity-severe { background: #fecaca; color: #b91c1c; }

.defect-details {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.detail-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.detail-label {
  font-size: 0.875rem;
  color: var(--text-secondary);
  min-width: 80px;
}

.severity-bar {
  flex: 1;
  height: 8px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
}

.severity-fill {
  height: 100%;
  background: linear-gradient(90deg, #fbbf24, #ef4444);
  border-radius: 4px;
}

.detail-value {
  font-size: 0.875rem;
  font-weight: 500;
  min-width: 40px;
}

/* Recommendations */
.section-subtitle {
  margin-bottom: 1rem;
  color: var(--text-secondary);
}

.recommendations-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.recommendation-card {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1rem;
}

.recommendation-card.was-clamped {
  border-color: #fbbf24;
}

.rec-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.75rem;
}

.rec-parameter {
  font-weight: 600;
}

.rec-priority {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  background: var(--bg-tertiary);
  border-radius: 4px;
  color: var(--text-secondary);
}

.rec-change {
  margin-bottom: 0.75rem;
}

.change-display {
  font-family: monospace;
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--accent-color);
}

.rec-rationale {
  margin-bottom: 0.75rem;
  padding: 0.75rem;
  background: var(--bg-tertiary);
  border-radius: 6px;
}

.rationale-text {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

.rec-meta {
  display: flex;
  gap: 1rem;
  font-size: 0.75rem;
  color: var(--text-tertiary);
}

.meta-clamped {
  color: #d97706;
}

/* Conflicts */
.conflicts-section {
  margin-top: 2rem;
}

.conflicts-warning {
  color: #d97706;
  margin-bottom: 1rem;
}

.conflicts-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.conflict-card {
  display: flex;
  gap: 1rem;
  background: #fef3c7;
  border: 1px solid #fbbf24;
  border-radius: 8px;
  padding: 1rem;
}

.conflict-icon {
  font-size: 1.5rem;
}

.conflict-param {
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.conflict-desc {
  margin-bottom: 0.5rem;
}

.conflict-defects {
  font-size: 0.875rem;
  color: #92400e;
}

.no-defects {
  padding: 2rem;
  text-align: center;
  background: #dcfce7;
  border-radius: 8px;
  color: #166534;
  font-weight: 500;
}
```
  </action>
  <verify>
    `cd /Users/michaelcurtis/Development/BambuMate && cargo build --target wasm32-unknown-unknown`
  </verify>
  <done>
    - Route /analysis registered in app.rs
    - Sidebar updated with Print Analysis nav item
    - CSS styles added for all analysis UI components
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete print analysis UI with:
    1. Drag-and-drop photo upload zone
    2. Material type selector
    3. Analysis results display with defects, recommendations, conflicts
    4. Quality badge and severity visualization
    5. Navigation from sidebar
  </what-built>
  <how-to-verify>
    1. Run `cd /Users/michaelcurtis/Development/BambuMate && cargo tauri dev`
    2. Click "Print Analysis" in sidebar
    3. Verify drop zone appears with browse button
    4. Drag a photo of a 3D print onto the drop zone (or browse)
    5. Verify image preview appears
    6. Select a material type (optional)
    7. Click "Analyze Print"
    8. Wait for analysis (10-30 seconds)
    9. Verify results show:
       - Overall quality badge
       - Detected defects with severity bars
       - Recommendations with "current -> suggested" format
       - Conflicts section (if applicable)
    10. Click "Analyze Another Photo" to reset
  </how-to-verify>
  <resume-signal>Type "approved" if analysis flow works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `cd /Users/michaelcurtis/Development/BambuMate && cargo build` - Full project builds
2. `cd /Users/michaelcurtis/Development/BambuMate && cargo build --target wasm32-unknown-unknown` - WASM builds
3. `cargo tauri dev` - App runs and shows Print Analysis page
4. Manual test: Upload a photo and verify analysis results display correctly
</verification>

<success_criteria>
- Print Analysis page accessible from sidebar
- Drop zone accepts drag-and-drop and file browse
- Image preview shown before analysis
- Analysis calls backend and displays results
- Defects shown with severity and confidence
- Recommendations show "current -> suggested" format
- Conflicts displayed when present
- Material type can be overridden
- User approved the functionality
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-print-analysis/06-03-SUMMARY.md`
</output>
